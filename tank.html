<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>B·∫Øn Xe TƒÉng</title>
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#2196f3">
  <link rel="icon" type="image/png" href="icon-192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="icon-192.png">
  <link rel="icon" type="image/png" sizes="192x192" href="icon-192.png">
  <link rel="apple-touch-icon" href="icon-192.png">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <style>
    * {
      box-sizing: border-box;
    }
    
    body {
      background: #222;
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
      overflow: hidden;
      width: 100vw;
      height: 100vh;
    }
    
    .game-container {
      position: relative;
      width: 100vw;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    
    canvas {
      background: #444;
      width: 100vw;
      height: 100vh;
      display: block;
    }
    
    /* Joystick - g√≥c tr√°i */
    .joystick-container {
      position: fixed;
      bottom: 30px;
      left: 30px;
      display: none;
      z-index: 10;
      width: 150px;
      height: 150px;
      touch-action: none;
    }
    
    .joystick-base {
      position: absolute;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.2);
      border: 2px solid #fff;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(5px);
    }
    
    .joystick-handle {
      position: absolute;
      width: 60px;
      height: 60px;
      background: rgba(255, 255, 255, 0.5);
      border: 2px solid #fff;
      border-radius: 50%;
      cursor: pointer;
      user-select: none;
      transition: transform 0.1s;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-weight: bold;
    }
    
    /* N√∫t b·∫Øn v√† b√¨nh nhi√™n li·ªáu - g√≥c ph·∫£i */
    .shoot-controls {
      position: fixed;
      bottom: 30px;
      right: 30px;
      display: none;
      z-index: 10;
      flex-direction: row;
      gap: 20px;
      align-items: center;
    }
    
    .shoot-btn {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: rgba(255, 235, 59, 0.3);
      border: 3px solid #ffeb3b;
      color: #ffeb3b;
      font-size: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      user-select: none;
      transition: all 0.1s;
      touch-action: manipulation;
      backdrop-filter: blur(5px);
    }
    
    .shoot-btn:hover {
      background: rgba(255, 235, 59, 0.5);
      transform: scale(1.1);
    }
    
    .shoot-btn:active {
      background: rgba(255, 235, 59, 0.7);
      transform: scale(0.9);
    }
    
    /* N√∫t b√¨nh nhi√™n li·ªáu */
    .fuel-btn {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: rgba(76, 175, 80, 0.3);
      border: 3px solid #4caf50;
      color: #4caf50;
      font-size: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      user-select: none;
      transition: all 0.1s;
      touch-action: manipulation;
      backdrop-filter: blur(5px);
      margin-bottom: 10px;
    }
    
    .fuel-btn:hover {
      background: rgba(76, 175, 80, 0.5);
      transform: scale(1.1);
    }
    
    .fuel-btn:active {
      background: rgba(76, 175, 80, 0.7);
      transform: scale(0.9);
    }
    
    .fuel-btn.disabled {
      background: rgba(128, 128, 128, 0.3);
      border-color: #808080;
      color: #808080;
      cursor: not-allowed;
      opacity: 0.5;
    }
    
    .fuel-btn.disabled:hover {
      transform: none;
      background: rgba(128, 128, 128, 0.3);
    }
    
    /* N√∫t tuy·ªát chi√™u s√≥ng ƒëi·ªán */
    .electric-wave-btn {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: rgba(138, 43, 226, 0.3);
      border: 3px solid #8a2be2;
      color: #8a2be2;
      font-size: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      user-select: none;
      transition: all 0.1s;
      touch-action: manipulation;
      backdrop-filter: blur(5px);
      margin-bottom: 10px;
      position: relative;
      overflow: hidden;
    }

    /* N√∫t tuy·ªát chi√™u t√™n l·ª≠a */
    .missile-btn {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: rgba(255, 87, 34, 0.3);
      border: 3px solid #ff5722;
      color: #ff5722;
      font-size: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      user-select: none;
      transition: all 0.1s;
      touch-action: manipulation;
      backdrop-filter: blur(5px);
      margin-bottom: 10px;
      position: relative;
      overflow: hidden;
    }

    /* N√∫t k·ªπ nƒÉng b·∫Øn laser */
    .bullet-time-btn {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: rgba(33, 150, 243, 0.3);
      border: 3px solid #2196f3;
      color: #2196f3;
      font-size: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      user-select: none;
      transition: all 0.1s;
      touch-action: manipulation;
      backdrop-filter: blur(5px);
      margin-bottom: 10px;
      position: relative;
      overflow: hidden;
    }
    
    .missile-btn:hover {
      background: rgba(255, 87, 34, 0.5);
      transform: scale(1.1);
      box-shadow: 0 0 20px rgba(255, 87, 34, 0.6);
    }
    
    .missile-btn:active {
      background: rgba(255, 87, 34, 0.7);
      transform: scale(0.9);
    }
    
    .missile-btn.disabled {
      background: rgba(128, 128, 128, 0.3);
      border-color: #808080;
      color: #808080;
      cursor: not-allowed;
      opacity: 0.5;
    }
    
    .missile-btn.disabled:hover {
      transform: none;
      background: rgba(128, 128, 128, 0.3);
      box-shadow: none;
    }
    
    .electric-wave-btn:hover {
      background: rgba(138, 43, 226, 0.5);
      transform: scale(1.1);
      box-shadow: 0 0 20px rgba(138, 43, 226, 0.6);
    }
    
    .electric-wave-btn:active {
      background: rgba(138, 43, 226, 0.7);
      transform: scale(0.9);
    }
    
    .electric-wave-btn.disabled {
      background: rgba(128, 128, 128, 0.3);
      border-color: #808080;
      color: #808080;
      cursor: not-allowed;
      opacity: 0.5;
    }
    
    .electric-wave-btn.disabled:hover {
      transform: none;
      background: rgba(128, 128, 128, 0.3);
      box-shadow: none;
    }

    .bullet-time-btn:hover {
      background: rgba(33, 150, 243, 0.5);
      transform: scale(1.1);
      box-shadow: 0 0 20px rgba(33, 150, 243, 0.6);
    }
    
    .bullet-time-btn:active {
      background: rgba(33, 150, 243, 0.7);
      transform: scale(0.9);
    }
    
    .bullet-time-btn.disabled {
      background: rgba(128, 128, 128, 0.3);
      border-color: #808080;
      color: #808080;
      cursor: not-allowed;
      opacity: 0.5;
    }
    
    .bullet-time-btn.disabled:hover {
      transform: none;
      background: rgba(128, 128, 128, 0.3);
      box-shadow: none;
    }

    .bullet-time-btn.active {
      background: rgba(33, 150, 243, 0.8);
      box-shadow: 0 0 30px rgba(33, 150, 243, 1);
      animation: bulletTimePulse 1s infinite;
    }

    @keyframes bulletTimePulse {
      0%, 100% { box-shadow: 0 0 30px rgba(33, 150, 243, 1); }
      50% { box-shadow: 0 0 50px rgba(33, 150, 243, 0.8); }
    }
    
    /* Hi·ªáu ·ª©ng cooldown cho n√∫t t√™n l·ª≠a */
    .missile-btn::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: conic-gradient(transparent 0deg, rgba(255, 87, 34, 0.8) 360deg);
      border-radius: 50%;
      opacity: 0;
      transition: opacity 0.3s;
    }
    
    .missile-btn.cooldown::after {
      opacity: 1;
      animation: cooldownSpin 0.1s linear;
    }

    /* Hi·ªáu ·ª©ng cooldown cho n√∫t s√≥ng ƒëi·ªán */
    .electric-wave-btn::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: conic-gradient(transparent 0deg, rgba(138, 43, 226, 0.8) 360deg);
      border-radius: 50%;
      opacity: 0;
      transition: opacity 0.3s;
    }
    
    .electric-wave-btn.cooldown::after {
      opacity: 1;
      animation: cooldownSpin 0.1s linear;
    }

    /* Hi·ªáu ·ª©ng cooldown cho n√∫t b·∫Øn laser */
    .bullet-time-btn::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: conic-gradient(transparent 0deg, rgba(33, 150, 243, 0.8) 360deg);
      border-radius: 50%;
      opacity: 0;
      transition: opacity 0.3s;
    }
    
    .bullet-time-btn.cooldown::after {
      opacity: 1;
      animation: cooldownSpin 0.1s linear;
    }
    
    @keyframes cooldownSpin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    
    /* Responsive cho m√†n h√¨nh nh·ªè */
    @media (max-width: 768px) {
      .joystick-container {
        width: 130px;
        height: 130px;
        bottom: 20px;
        left: 20px;
      }
      
      .joystick-handle {
        width: 50px;
        height: 50px;
      }
      
      .shoot-controls {
        bottom: 20px;
        right: 20px;
        gap: 15px;
      }
      
      .shoot-btn {
        width: 70px;
        height: 70px;
        font-size: 28px;
      }
      
      .fuel-btn {
        width: 70px;
        height: 70px;
        font-size: 28px;
      }
      
      .electric-wave-btn {
        width: 70px;
        height: 70px;
        font-size: 28px;
      }
      
      .missile-btn {
        width: 70px;
        height: 70px;
        font-size: 28px;
      }
      
      .bullet-time-btn {
        width: 70px;
        height: 70px;
        font-size: 28px;
      }
    }
    
    @media (max-width: 480px) {
      .joystick-container {
        width: 120px;
        height: 120px;
        bottom: 15px;
        left: 15px;
      }
      
      .joystick-handle {
        width: 45px;
        height: 45px;
      }
      
      .shoot-controls {
        bottom: 15px;
        right: 15px;
        gap: 12px;
      }
      
      .shoot-btn {
        width: 65px;
        height: 65px;
        font-size: 24px;
      }
      
      .fuel-btn {
        width: 65px;
        height: 65px;
        font-size: 24px;
      }
      
      .electric-wave-btn {
        width: 65px;
        height: 65px;
        font-size: 24px;
      }
      
      .missile-btn {
        width: 65px;
        height: 65px;
        font-size: 24px;
      }
      
      .bullet-time-btn {
        width: 65px;
        height: 65px;
        font-size: 24px;
      }
    }
    
    @media (max-width: 360px) {
      .joystick-container {
        width: 100px;
        height: 100px;
        bottom: 10px;
        left: 10px;
      }
      
      .joystick-handle {
        width: 40px;
        height: 40px;
      }
      
      .shoot-controls {
        bottom: 10px;
        right: 10px;
        gap: 10px;
      }
      
      .shoot-btn {
        width: 55px;
        height: 55px;
        font-size: 20px;
      }
      
      .fuel-btn {
        width: 55px;
        height: 55px;
        font-size: 20px;
      }
      
      .electric-wave-btn {
        width: 55px;
        height: 55px;
        font-size: 20px;
      }
      
      .missile-btn {
        width: 55px;
        height: 55px;
        font-size: 20px;
      }
      
      .bullet-time-btn {
        width: 55px;
        height: 55px;
        font-size: 20px;
      }
    }
  </style>
</head>
<body>
  <div class="game-container">
    <button id="startBtn" style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:2em;padding:0.8em 2em;z-index:20;border:none;background:#4caf50;color:#fff;border-radius:15px;cursor:pointer;box-shadow:0 4px 15px rgba(0,0,0,0.3);">üéÆ B·∫Øt ƒë·∫ßu</button>
    <canvas id="gameCanvas" style="display:none;"></canvas>
    
    <!-- Joystick - g√≥c tr√°i -->
    <div class="joystick-container" id="joystickContainer">
      <div class="joystick-base" id="joystickBase">
        <div class="joystick-handle" id="joystickHandle"></div>
      </div>
    </div>
    
    <!-- N√∫t b·∫Øn v√† b√¨nh nhi√™n li·ªáu - g√≥c ph·∫£i -->
    <div class="shoot-controls" id="shootControls">
      <button class="missile-btn" id="missileBtn">
        <svg width="32" height="32" viewBox="0 0 32 32" fill="currentColor">
          <path d="M16 2 L20 8 L16 12 L12 8 Z"/>
          <rect x="14" y="8" width="4" height="16" rx="2"/>
          <path d="M12 20 L16 24 L20 20"/>
          <circle cx="16" cy="16" r="2" fill="#ffeb3b"/>
          <path d="M8 12 L12 14 L8 16 Z" fill="#ff9800"/>
          <path d="M24 12 L20 14 L24 16 Z" fill="#ff9800"/>
        </svg>
      </button>
      <button class="bullet-time-btn" id="bulletTimeBtn">üî¥</button>
      <button class="electric-wave-btn" id="electricWaveBtn">‚ö°</button>
      <button class="fuel-btn" id="fuelBtn">‚õΩ</button>
      <button class="shoot-btn" id="shootBtn"><img src="bullet.png" alt="Bullet" style="width: 30px; height: 30px;"></button>
    </div>
  </div>
  
  <audio id="bgm" src="my-love-don-t-let-love-fade.mp3" loop></audio>
  <script>

    // ƒêƒÉng k√Ω service worker cho PWA
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', function() {
        navigator.serviceWorker.register('sw.js').then(function(reg) {
          // Service worker registered
        }, function(err) {
          // Registration failed
        });
      });
    }

    const startBtn = document.getElementById('startBtn');
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const bgm = document.getElementById('bgm');
    const joystickContainer = document.getElementById('joystickContainer');
    const joystickBase = document.getElementById('joystickBase');
    const joystickHandle = document.getElementById('joystickHandle');
    const shootControls = document.getElementById('shootControls');
    const fuelBtn = document.getElementById('fuelBtn');
    const electricWaveBtn = document.getElementById('electricWaveBtn');
    const missileBtn = document.getElementById('missileBtn');
    const bulletTimeBtn = document.getElementById('bulletTimeBtn');
    
    // Thi·∫øt l·∫≠p canvas fullscreen
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    
    // G·ªçi resize khi t·∫£i trang v√† khi thay ƒë·ªïi k√≠ch th∆∞·ªõc
    window.addEventListener('resize', function() {
      if (gameStarted) {
        resizeCanvas();
      }
    });
    resizeCanvas();

    let gameStarted = false;
    
    // H·ªá th·ªëng chi·∫øn th·∫Øng
    const victorySystem = {
      enemiesKilled: 0,
      targetKills: 30,
      gameWon: false
    };

    // H·ªá th·ªëng tuy·ªát chi√™u s√≥ng ƒëi·ªán
    const electricWaveSystem = {
      isReady: true,
      cooldownTime: 5000, // 5 gi√¢y cooldown
      currentCooldown: 0,
      waves: [], // M·∫£ng ch·ª©a c√°c s√≥ng ƒëi·ªán ƒëang ho·∫°t ƒë·ªông
      waveRadius: 300, // B√°n k√≠nh t·ªëi ƒëa c·ªßa s√≥ng
      waveDamage: 5, // S√°t th∆∞∆°ng c·ªßa s√≥ng ƒëi·ªán
      waveSpeed: 8 // T·ªëc ƒë·ªô lan truy·ªÅn s√≥ng
    };

    // H·ªá th·ªëng tuy·ªát chi√™u t√™n l·ª≠a
    const missileSystem = {
      isReady: true,
      cooldownTime:  1000, // 3 gi√¢y cooldown
      currentCooldown: 0,
      missiles: [], // M·∫£ng ch·ª©a c√°c t√™n l·ª≠a ƒëang bay
      missileSpeed: 6, // T·ªëc ƒë·ªô t√™n l·ª≠a
      missileDamage: 10, // S√°t th∆∞∆°ng c·ªßa t√™n l·ª≠a
      explosionRadius: 80, // B√°n k√≠nh n·ªï
      homingRange: 200 // Ph·∫°m vi t·ª± ƒë·ªông t√¨m m·ª•c ti√™u
    };

    // H·ªá th·ªëng b·∫£n ƒë·ªì v√¥ t·∫≠n
    const worldSystem = {
      offsetX: 0,
      offsetY: 0,
      tileSize: 40,
      terrain: [],
      decorations: []
    };

    // Sinh ƒë·ªãa h√¨nh v√† trang tr√≠
    function generateTerrain(startX, startY, width, height) {
      for (let x = startX; x < startX + width; x++) {
        for (let y = startY; y < startY + height; y++) {
          let key = `${x},${y}`;
          if (!worldSystem.terrain[key]) {
            // Sinh ƒë·ªãa h√¨nh c∆° b·∫£n
            let terrainType = 'grass';
            if (Math.random() < 0.1) terrainType = 'dirt';
            else if (Math.random() < 0.05) terrainType = 'stone';
            
            worldSystem.terrain[key] = {
              type: terrainType,
              x: x,
              y: y
            };
            
            // Sinh trang tr√≠
            if (Math.random() < 0.08) {
              let decorationType = 'grass_tuft';
              if (Math.random() < 0.3) decorationType = 'small_rock';
              else if (Math.random() < 0.1) decorationType = 'tree';
              else if (Math.random() < 0.2) decorationType = 'bush';
              
              worldSystem.decorations.push({
                type: decorationType,
                x: x * worldSystem.tileSize + Math.random() * worldSystem.tileSize,
                y: y * worldSystem.tileSize + Math.random() * worldSystem.tileSize,
                size: 0.5 + Math.random() * 0.5
              });
            }
          }
        }
      }
    }

    // V·∫Ω ƒë·ªãa h√¨nh
    function drawTerrain() {
      const startTileX = Math.floor(worldSystem.offsetX / worldSystem.tileSize) - 1;
      const startTileY = Math.floor(worldSystem.offsetY / worldSystem.tileSize) - 1;
      const endTileX = startTileX + Math.ceil(canvas.width / worldSystem.tileSize) + 2;
      const endTileY = startTileY + Math.ceil(canvas.height / worldSystem.tileSize) + 2;
      
      // Sinh th√™m ƒë·ªãa h√¨nh n·∫øu c·∫ßn
      generateTerrain(startTileX, startTileY, endTileX - startTileX, endTileY - startTileY);
      
      // V·∫Ω ƒë·ªãa h√¨nh
      for (let x = startTileX; x < endTileX; x++) {
        for (let y = startTileY; y < endTileY; y++) {
          let key = `${x},${y}`;
          let terrain = worldSystem.terrain[key];
          if (terrain) {
            let screenX = x * worldSystem.tileSize - worldSystem.offsetX;
            let screenY = y * worldSystem.tileSize - worldSystem.offsetY;
            
            switch (terrain.type) {
              case 'grass':
                ctx.fillStyle = '#4a7c59';
                break;
              case 'dirt':
                ctx.fillStyle = '#8b4513';
                break;
              case 'stone':
                ctx.fillStyle = '#696969';
                break;
            }
            ctx.fillRect(screenX, screenY, worldSystem.tileSize, worldSystem.tileSize);
          }
        }
      }
    }

    // V·∫Ω trang tr√≠
    function drawDecorations() {
      for (let decoration of worldSystem.decorations) {
        let screenX = decoration.x - worldSystem.offsetX;
        let screenY = decoration.y - worldSystem.offsetY;
        
        // Ch·ªâ v·∫Ω n·∫øu trong ph·∫°m vi m√†n h√¨nh
        if (screenX > -50 && screenX < canvas.width + 50 && 
            screenY > -50 && screenY < canvas.height + 50) {
          
          ctx.save();
          let size = decoration.size * 20;
          
          switch (decoration.type) {
            case 'grass_tuft':
              ctx.fillStyle = '#228B22';
              ctx.beginPath();
              for (let i = 0; i < 5; i++) {
                let angle = (i / 5) * Math.PI * 2;
                let x = screenX + Math.cos(angle) * size * 0.3;
                let y = screenY + Math.sin(angle) * size * 0.2;
                ctx.lineTo(x, y);
              }
              ctx.fill();
              break;
              
            case 'small_rock':
              ctx.fillStyle = '#A0A0A0';
              ctx.beginPath();
              ctx.arc(screenX, screenY, size * 0.4, 0, Math.PI * 2);
              ctx.fill();
              ctx.fillStyle = '#808080';
              ctx.beginPath();
              ctx.arc(screenX - size * 0.1, screenY - size * 0.1, size * 0.2, 0, Math.PI * 2);
              ctx.fill();
              break;
              
            case 'tree':
              // Th√¢n c√¢y
              ctx.fillStyle = '#8B4513';
              ctx.fillRect(screenX - size * 0.1, screenY - size * 0.3, size * 0.2, size * 0.6);
              // L√° c√¢y
              ctx.fillStyle = '#228B22';
              ctx.beginPath();
              ctx.arc(screenX, screenY - size * 0.3, size * 0.4, 0, Math.PI * 2);
              ctx.fill();
              break;
              
            case 'bush':
              ctx.fillStyle = '#32CD32';
              ctx.beginPath();
              ctx.arc(screenX, screenY, size * 0.3, 0, Math.PI * 2);
              ctx.fill();
              ctx.fillStyle = '#228B22';
              ctx.beginPath();
              ctx.arc(screenX - size * 0.1, screenY - size * 0.1, size * 0.2, 0, Math.PI * 2);
              ctx.fill();
              break;
          }
          ctx.restore();
        }
      }
    }

    const tank = {
        x: 400, // V·ªã tr√≠ tr√™n m√†n h√¨nh
        y: 300, // V·ªã tr√≠ tr√™n m√†n h√¨nh
        speed: 3,
        hp: 10,
        maxHp: 10,
        worldX: 400, // V·ªã tr√≠ th·ª±c trong th·∫ø gi·ªõi
        worldY: 300,
        shootCooldown: 0,
        shootInterval: 10, // Th·ªùi gian ch·ªù gi·ªØa c√°c l·∫ßn b·∫Øn (frames)
        angle: -Math.PI / 2, // G√≥c xoay c·ªßa xe tƒÉng (m·∫∑c ƒë·ªãnh h∆∞·ªõng l√™n)
        turretAngle: -Math.PI / 2, // G√≥c xoay c·ªßa n√≤ng ph√°o (c√≥ th·ªÉ kh√°c v·ªõi th√¢n xe)
        autoAim: true, // B·∫≠t t·ª± ƒë·ªông nh·∫Øm
        canShootWhileMoving: true, // C√≥ th·ªÉ b·∫Øn trong khi di chuy·ªÉn
        autoShoot: false // B·∫Øn t·ª± ƒë·ªông khi c√≥ m·ª•c ti√™u
    };

    // Xe tƒÉng nh·ªè h·ªó tr·ª£
    const supportTank = {
        x: 350, // V·ªã tr√≠ tr√™n m√†n h√¨nh
        y: 350, // V·ªã tr√≠ tr√™n m√†n h√¨nh
        speed: 2.5, // Ch·∫≠m h∆°n xe tƒÉng ch√≠nh m·ªôt ch√∫t
        hp: 5,
        maxHp: 5,
        worldX: 350, // V·ªã tr√≠ th·ª±c trong th·∫ø gi·ªõi
        worldY: 350,
        targetDistance: 80, // Kho·∫£ng c√°ch m·ª•c ti√™u t·ª´ xe tƒÉng ch√≠nh
        followAngle: Math.PI * 1.25, // G√≥c theo (b·∫Øt ƒë·∫ßu ·ªü ph√≠a sau b√™n tr√°i)
        shootCooldown: 0,
        shootInterval: 45 // B·∫Øn m·ªói 45 frames (ch·∫≠m h∆°n xe tƒÉng ch√≠nh)
    };

    let bullets = [];
    const bulletSpeed = 10;

    // ƒê·∫°n c·ªßa xe tƒÉng h·ªó tr·ª£
    let supportBullets = [];
    const supportBulletSpeed = 8;

    // ƒê·∫°n c·ªßa xe tƒÉng ƒë·ªãch
    let enemyBullets = [];
    const enemyBulletSpeed = 5;


    function drawBullet(bullet, color = '#ffeb3b') {
      // N·∫øu l√† laser, v·∫Ω tia laser thay v√¨ vi√™n ƒë·∫°n tr√≤n
      if (bullet.isLaser) {
        drawLaser(bullet);
      } else {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(bullet.x, bullet.y, 5, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function drawLaser(bullet) {
      ctx.save();
      
      // T√≠nh to√°n ƒëi·ªÉm b·∫Øt ƒë·∫ßu t·ª´ xe tƒÉng
      const startX = tank.x + 30; // Gi·ªØa xe tƒÉng
      const startY = tank.y + 10; // Ph√≠a tr∆∞·ªõc xe tƒÉng
      
      // T√≠nh to√°n ƒëi·ªÉm cu·ªëi c·ªßa tia laser (b·∫Øn th·∫≥ng l√™n)
      const laserLength = canvas.height + 100; // ƒê·ªô d√†i tia laser ƒë·∫øn h·∫øt m√†n h√¨nh
      const endX = startX;
      const endY = startY - laserLength;
      
      // V·∫Ω tia laser ngo√†i (m√†u xanh d∆∞∆°ng ƒë·∫≠m v·ªõi hi·ªáu ·ª©ng ph√°t s√°ng)
      ctx.strokeStyle = '#0080ff';
      ctx.lineWidth = 12;
      ctx.lineCap = 'round';
      ctx.shadowColor = '#0080ff';
      ctx.shadowBlur = 20;
      ctx.beginPath();
      ctx.moveTo(startX, startY);
      ctx.lineTo(endX, endY);
      ctx.stroke();
      
      // V·∫Ω tia laser gi·ªØa (m√†u xanh d∆∞∆°ng s√°ng)
      ctx.strokeStyle = '#00bfff';
      ctx.lineWidth = 8;
      ctx.shadowBlur = 15;
      ctx.beginPath();
      ctx.moveTo(startX, startY);
      ctx.lineTo(endX, endY);
      ctx.stroke();
      
      // V·∫Ω l√µi laser (m√†u tr·∫Øng)
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 4;
      ctx.shadowBlur = 8;
      ctx.beginPath();
      ctx.moveTo(startX, startY);
      ctx.lineTo(endX, endY);
      ctx.stroke();
      
      // V·∫Ω hi·ªáu ·ª©ng l·∫•p l√°nh d·ªçc theo tia laser
      for (let i = 0; i < 8; i++) {
        const sparkY = startY - (i * 80 + Math.random() * 60);
        const sparkX = startX + (Math.random() - 0.5) * 20;
        
        ctx.fillStyle = '#ffffff';
        ctx.shadowColor = '#00bfff';
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.arc(sparkX, sparkY, 1 + Math.random() * 2, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // V·∫Ω hi·ªáu ·ª©ng nƒÉng l∆∞·ª£ng ·ªü ƒë·∫ßu s√∫ng
      ctx.fillStyle = '#ffffff';
      ctx.shadowColor = '#00bfff';
      ctx.shadowBlur = 15;
      ctx.beginPath();
      ctx.arc(startX, startY, 8, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.restore();
    }

    function drawExplosion(x, y) {
      ctx.save();
      ctx.beginPath();
      ctx.arc(x + 30, y + 35, 25, 0, Math.PI * 2);
      ctx.fillStyle = 'orange';
      ctx.globalAlpha = 0.7;
      ctx.fill();
      ctx.beginPath();
      ctx.arc(x + 30, y + 35, 12, 0, Math.PI * 2);
      ctx.fillStyle = 'yellow';
      ctx.globalAlpha = 0.9;
      ctx.fill();
      ctx.globalAlpha = 1;
      ctx.restore();
    }

    // H√†m s·ª≠ d·ª•ng tuy·ªát chi√™u s√≥ng ƒëi·ªán
    function useElectricWave() {
      if (!electricWaveSystem.isReady) return;
      
      // T·∫°o s√≥ng ƒëi·ªán m·ªõi
      electricWaveSystem.waves.push({
        x: tank.x + 30, // T√¢m xe tƒÉng
        y: tank.y + 35,
        worldX: tank.worldX + 30,
        worldY: tank.worldY + 35,
        radius: 0,
        maxRadius: electricWaveSystem.waveRadius,
        speed: electricWaveSystem.waveSpeed,
        damage: electricWaveSystem.waveDamage,
        opacity: 1,
        hitEnemies: [] // Danh s√°ch k·∫ª ƒë·ªãch ƒë√£ b·ªã tr√∫ng ƒë·ªÉ tr√°nh hit nhi·ªÅu l·∫ßn
      });
      
      // B·∫Øt ƒë·∫ßu cooldown
      electricWaveSystem.isReady = false;
      electricWaveSystem.currentCooldown = electricWaveSystem.cooldownTime;
      updateElectricWaveButton();
    }

    // H√†m v·∫Ω s√≥ng ƒëi·ªán
    function drawElectricWave(wave) {
      ctx.save();
      
      // V·∫Ω v√≤ng tr√≤n s√≥ng ƒëi·ªán ch√≠nh
      ctx.beginPath();
      ctx.arc(wave.x, wave.y, wave.radius, 0, Math.PI * 2);
      ctx.strokeStyle = `rgba(138, 43, 226, ${wave.opacity})`;
      ctx.lineWidth = 4;
      ctx.stroke();
      
      // V·∫Ω hi·ªáu ·ª©ng tia ch·ªõp
      ctx.strokeStyle = `rgba(255, 255, 255, ${wave.opacity * 0.8})`;
      ctx.lineWidth = 2;
      for (let i = 0; i < 8; i++) {
        let angle = (i / 8) * Math.PI * 2;
        let innerRadius = wave.radius * 0.7;
        let outerRadius = wave.radius * 1.1;
        
        ctx.beginPath();
        ctx.moveTo(
          wave.x + Math.cos(angle) * innerRadius,
          wave.y + Math.sin(angle) * innerRadius
        );
        ctx.lineTo(
          wave.x + Math.cos(angle) * outerRadius,
          wave.y + Math.sin(angle) * outerRadius
        );
        ctx.stroke();
      }
      
      // V·∫Ω v√≤ng tr√≤n b√™n trong v·ªõi hi·ªáu ·ª©ng ph√°t s√°ng
      if (wave.radius > 20) {
        ctx.beginPath();
        ctx.arc(wave.x, wave.y, wave.radius * 0.3, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(138, 43, 226, ${wave.opacity * 0.3})`;
        ctx.fill();
      }
      
      ctx.restore();
    }

    // H√†m c·∫≠p nh·∫≠t n√∫t s√≥ng ƒëi·ªán
    function updateElectricWaveButton() {
      if (electricWaveSystem.isReady) {
        electricWaveBtn.classList.remove('disabled');
        electricWaveBtn.classList.remove('cooldown');
        electricWaveBtn.style.opacity = '1';
      } else {
        electricWaveBtn.classList.add('disabled');
        electricWaveBtn.classList.add('cooldown');
        electricWaveBtn.style.opacity = '0.5';
      }
    }

    // H√†m s·ª≠ d·ª•ng tuy·ªát chi√™u t√™n l·ª≠a
    function useMissile() {
      if (!missileSystem.isReady) return;
      
      // T·∫°o t√™n l·ª≠a m·ªõi
      missileSystem.missiles.push({
        x: tank.x + 30, // T√¢m xe tƒÉng
        y: tank.y + 35,
        worldX: tank.worldX + 30,
        worldY: tank.worldY + 35,
        vx: 0, // V·∫≠n t·ªëc ban ƒë·∫ßu
        vy: -missileSystem.missileSpeed,
        target: null, // M·ª•c ti√™u hi·ªán t·∫°i
        hasExploded: false,
        trailPoints: [] // ƒêi·ªÉm ƒë·ªÉ v·∫Ω ƒëu√¥i kh√≥i
      });
      
      // B·∫Øt ƒë·∫ßu cooldown
      missileSystem.isReady = false;
      missileSystem.currentCooldown = missileSystem.cooldownTime;
      updateMissileButton();
    }

    // H√†m v·∫Ω t√™n l·ª≠a
    function drawMissile(missile) {
      ctx.save();
      
      // V·∫Ω ƒëu√¥i kh√≥i
      if (missile.trailPoints.length > 1) {
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(missile.trailPoints[0].x, missile.trailPoints[0].y);
        for (let i = 1; i < missile.trailPoints.length; i++) {
          let alpha = i / missile.trailPoints.length * 0.6;
          ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
          ctx.lineTo(missile.trailPoints[i].x, missile.trailPoints[i].y);
        }
        ctx.stroke();
      }
      
      // T√≠nh g√≥c quay c·ªßa t√™n l·ª≠a
      let angle = Math.atan2(missile.vy, missile.vx) + Math.PI / 2;
      
      ctx.translate(missile.x, missile.y);
      ctx.rotate(angle);
      
      // V·∫Ω th√¢n t√™n l·ª≠a
      ctx.fillStyle = '#ff5722';
      ctx.fillRect(-4, -12, 8, 24);
      
      // V·∫Ω ƒë·∫ßu t√™n l·ª≠a
      ctx.fillStyle = '#d32f2f';
      ctx.beginPath();
      ctx.moveTo(0, -12);
      ctx.lineTo(-4, -8);
      ctx.lineTo(4, -8);
      ctx.closePath();
      ctx.fill();
      
      // V·∫Ω c√°nh t√™n l·ª≠a
      ctx.fillStyle = '#ff9800';
      ctx.beginPath();
      ctx.moveTo(-6, 8);
      ctx.lineTo(-2, 4);
      ctx.lineTo(-2, 12);
      ctx.closePath();
      ctx.fill();
      
      ctx.beginPath();
      ctx.moveTo(6, 8);
      ctx.lineTo(2, 4);
      ctx.lineTo(2, 12);
      ctx.closePath();
      ctx.fill();
      
      // V·∫Ω l·ª≠a ph√≠a sau
      ctx.fillStyle = '#ffeb3b';
      ctx.beginPath();
      ctx.moveTo(-2, 12);
      ctx.lineTo(0, 18);
      ctx.lineTo(2, 12);
      ctx.closePath();
      ctx.fill();
      
      ctx.restore();
    }

    // H√†m v·∫Ω v·ª• n·ªï t√™n l·ª≠a
    function drawMissileExplosion(x, y, radius, opacity) {
      ctx.save();
      
      // V√≤ng n·ªï ch√≠nh
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(255, 87, 34, ${opacity})`;
      ctx.fill();
      
      // V√≤ng n·ªï b√™n trong
      ctx.beginPath();
      ctx.arc(x, y, radius * 0.7, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(255, 193, 7, ${opacity})`;
      ctx.fill();
      
      // V√≤ng n·ªï trung t√¢m
      ctx.beginPath();
      ctx.arc(x, y, radius * 0.4, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
      ctx.fill();
      
      ctx.restore();
    }

    // H√†m c·∫≠p nh·∫≠t n√∫t t√™n l·ª≠a
    function updateMissileButton() {
      if (missileSystem.isReady) {
        missileBtn.classList.remove('disabled');
        missileBtn.classList.remove('cooldown');
        missileBtn.style.opacity = '1';
      } else {
        missileBtn.classList.add('disabled');
        missileBtn.classList.add('cooldown');
        missileBtn.style.opacity = '0.5';
      }
    }

// H√†m t√¨m k·∫ª th√π g·∫ßn nh·∫•t ƒë·ªÉ nh·∫Øm
function findNearestEnemy(tankX, tankY) {
  let nearestEnemy = null;
  let minDistance = Infinity;
  
  for (let enemy of enemies) {
    if (enemy.hp <= 0) continue; // B·ªè qua k·∫ª th√π ƒë√£ ch·∫øt
    
    let dx = enemy.x + 30 - (tankX + 30); // T√≠nh t·ª´ t√¢m xe tƒÉng
    let dy = enemy.y + 35 - (tankY + 35);
    let distance = Math.sqrt(dx * dx + dy * dy);
    
    if (distance < minDistance) {
      minDistance = distance;
      nearestEnemy = enemy;
    }
  }
  
  return nearestEnemy;
}

// H√†m t√≠nh g√≥c nh·∫Øm ƒë·∫øn m·ª•c ti√™u
function calculateAimAngle(fromX, fromY, toX, toY) {
  let dx = toX - fromX;
  let dy = toY - fromY;
  return Math.atan2(dy, dx);
}

function drawTank(x, y, color = '#4caf50', turretColor = '#388e3c', reverse = false, hp, maxHp, angle = -Math.PI/2, turretAngle = null) {
  // reverse = false: xe tƒÉng h∆∞·ªõng l√™n, true: h∆∞·ªõng xu·ªëng
  // angle: g√≥c xoay c·ªßa th√¢n xe tƒÉng
  // turretAngle: g√≥c xoay c·ªßa n√≤ng ph√°o (n·∫øu null th√¨ d√πng angle)
  ctx.save();
  
  // N·∫øu l√† xe tƒÉng enemy th√¨ v·∫Ω theo c√°ch c≈©
  if (reverse) {
    ctx.translate(x + 30, y + 35);
    ctx.rotate(Math.PI);
    ctx.translate(-x - 30, -y - 35);
  }
  // V·∫Ω c·ªôt m√°u n·∫øu c√≥ hp v√† maxHp (∆∞u ti√™n v·∫Ω tr∆∞·ªõc ƒë·ªÉ kh√¥ng b·ªã che)
  if (typeof hp === 'number' && typeof maxHp === 'number') {
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.strokeRect(x + 5, y - 15, 50, 7);
    // Thanh m√°u n·ªÅn
    ctx.fillStyle = '#f44336';
    ctx.fillRect(x + 5, y - 15, 50, 7);
    // ƒê·ªïi m√†u health bar theo ph·∫ßn trƒÉm m√°u
    let percent = Math.max(0, Math.min(1, hp / maxHp));
    if (percent > 0.6) ctx.fillStyle = '#76ff03'; // xanh
    else if (percent > 0.3) ctx.fillStyle = '#ffeb3b'; // v√†ng
    else ctx.fillStyle = '#f44336'; // ƒë·ªè
    ctx.fillRect(x + 5, y - 15, 50 * percent, 7);
  }
  
  // V·∫Ω xe tƒÉng v·ªõi n√≤ng ph√°o xoay ƒë∆∞·ª£c (ch·ªâ cho xe tƒÉng ng∆∞·ªùi ch∆°i)
  if (!reverse && turretAngle !== null) {
    // V·∫Ω xe tƒÉng v·ªõi th√¢n xe c√≥ th·ªÉ xoay
    ctx.save();
    ctx.translate(x + 30, y + 35); // Di chuy·ªÉn ƒë·∫øn t√¢m xe tƒÉng
    ctx.rotate(angle + Math.PI/2); // Xoay th√¢n xe theo h∆∞·ªõng di chuy·ªÉn
    
    // Th√¢n xe (v·∫Ω t·ª´ t√¢m)
    ctx.fillStyle = color;
    ctx.fillRect(-30, -15, 60, 30);
    
    // B√°nh xe (v·∫Ω t·ª´ t√¢m)
    ctx.fillStyle = '#222';
    for (let i = 0; i < 3; i++) {
      ctx.beginPath();
      ctx.arc(-15 + i * 15, 15, 8, 0, Math.PI * 2);
      ctx.fill();
    }
    
    ctx.restore();
    
    // Th√°p ph√°o (lu√¥n ·ªü t√¢m xe tƒÉng, kh√¥ng xoay theo th√¢n xe)
    ctx.fillStyle = turretColor;
    ctx.fillRect(x + 15, y + 20, 30, 30);
    
    // V·∫Ω n√≤ng ph√°o xoay ƒë∆∞·ª£c
    ctx.save();
    ctx.translate(x + 30, y + 35); // Di chuy·ªÉn ƒë·∫øn t√¢m th√°p ph√°o
    ctx.rotate(turretAngle); // Xoay theo g√≥c nh·∫Øm
    
    // V·∫Ω n√≤ng ph√°o
    ctx.fillStyle = '#222';
    ctx.fillRect(-3, -20, 6, 20); // N√≤ng ph√°o t·ª´ t√¢m th√°p ph√°o
    
    ctx.restore();
  } else {
    // V·∫Ω xe tƒÉng enemy theo c√°ch c≈©
    // Th√¢n xe
    ctx.fillStyle = color;
    ctx.fillRect(x, y + 20, 60, 30);
    // Th√°p ph√°o
    ctx.fillStyle = turretColor;
    ctx.fillRect(x + 15, y, 30, 30);
    // N√≤ng ph√°o
    ctx.fillStyle = '#222';
    ctx.fillRect(x + 27, y - 20, 6, 20);
    // B√°nh xe
    ctx.fillStyle = '#222';
    for (let i = 0; i < 3; i++) {
      ctx.beginPath();
      ctx.arc(x + 15 + i * 15, y + 50, 8, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  
  ctx.restore();
}

// H√†m v·∫Ω xe tƒÉng nh·ªè h·ªó tr·ª£ (60% k√≠ch th∆∞·ªõc xe tƒÉng ch√≠nh)
function drawSupportTank(x, y, color = '#2196f3', turretColor = '#1976d2', hp, maxHp) {
  ctx.save();
  
  // V·∫Ω c·ªôt m√°u n·∫øu c√≥ hp v√† maxHp
  if (typeof hp === 'number' && typeof maxHp === 'number') {
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 1.5;
    ctx.strokeRect(x + 3, y - 12, 30, 5);
    // Thanh m√°u n·ªÅn
    ctx.fillStyle = '#f44336';
    ctx.fillRect(x + 3, y - 12, 30, 5);
    // ƒê·ªïi m√†u health bar theo ph·∫ßn trƒÉm m√°u
    let percent = Math.max(0, Math.min(1, hp / maxHp));
    if (percent > 0.6) ctx.fillStyle = '#76ff03'; // xanh
    else if (percent > 0.3) ctx.fillStyle = '#ffeb3b'; // v√†ng
    else ctx.fillStyle = '#f44336'; // ƒë·ªè
    ctx.fillRect(x + 3, y - 12, 30 * percent, 5);
  }
  
  // Th√¢n xe (60% k√≠ch th∆∞·ªõc)
  ctx.fillStyle = color;
  ctx.fillRect(x, y + 12, 36, 18);
  
  // Th√°p ph√°o (60% k√≠ch th∆∞·ªõc)
  ctx.fillStyle = turretColor;
  ctx.fillRect(x + 9, y, 18, 18);
  
  // N√≤ng ph√°o (60% k√≠ch th∆∞·ªõc)
  ctx.fillStyle = '#222';
  ctx.fillRect(x + 16, y - 12, 4, 12);
  
  // B√°nh xe (60% k√≠ch th∆∞·ªõc)
  ctx.fillStyle = '#222';
  for (let i = 0; i < 3; i++) {
    ctx.beginPath();
    ctx.arc(x + 9 + i * 9, y + 30, 5, 0, Math.PI * 2);
    ctx.fill();
  }
  
  ctx.restore();
}

// Enemy tanks
let enemies = [];
const enemySpeed = 2;
const enemySpawnInterval = 120; // frames - gi·∫£m t·ªëc ƒë·ªô spawn 10 l·∫ßn
let frameCount = 0;
let enemyIdCounter = 0; // ƒê·∫øm ID duy nh·∫•t cho m·ªói k·∫ª ƒë·ªãch

function spawnEnemy() {
  // Random x position trong th·∫ø gi·ªõi, spawn ph√≠a tr√™n tank
  const x = Math.floor(Math.random() * (canvas.width - 60));
  const worldX = x + worldSystem.offsetX;
  const worldY = worldSystem.offsetY - 100; // Spawn ph√≠a tr√™n v√πng nh√¨n th·∫•y
  
  // enemy s·∫Ω c√≥ h∆∞·ªõng di chuy·ªÉn ng·∫´u nhi√™n ban ƒë·∫ßu
  const dx = Math.random() < 0.5 ? enemySpeed : -enemySpeed;
  const dy = 1.5; // t·ªëc ƒë·ªô xu·ªëng ·ªïn ƒë·ªãnh
  
  // Th√™m h·ªá th·ªëng m√°u cho xe tƒÉng ƒë·ªãch v√† v·ªã tr√≠ th·∫ø gi·ªõi
  enemies.push({ 
    id: enemyIdCounter++, // ID duy nh·∫•t
    x: x, 
    y: -100, 
    dx: dx, 
    dy: dy, 
    hp: 3, 
    maxHp: 3,
    worldX: worldX,
    worldY: worldY
  });
}

    function clear() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    // H√†m c·∫≠p nh·∫≠t xe tƒÉng h·ªó tr·ª£
    function updateSupportTank() {
      if (supportTank.hp <= 0) return; // Kh√¥ng c·∫≠p nh·∫≠t n·∫øu xe tƒÉng h·ªó tr·ª£ ƒë√£ ch·∫øt
      
      // T√≠nh v·ªã tr√≠ m·ª•c ti√™u xung quanh xe tƒÉng ch√≠nh
      let targetWorldX = tank.worldX + Math.cos(supportTank.followAngle) * supportTank.targetDistance;
      let targetWorldY = tank.worldY + Math.sin(supportTank.followAngle) * supportTank.targetDistance;
      
      // T√≠nh kho·∫£ng c√°ch ƒë·∫øn v·ªã tr√≠ m·ª•c ti√™u
      let dx = targetWorldX - supportTank.worldX;
      let dy = targetWorldY - supportTank.worldY;
      let distance = Math.sqrt(dx * dx + dy * dy);
      
      // Di chuy·ªÉn v·ªÅ ph√≠a v·ªã tr√≠ m·ª•c ti√™u n·∫øu qu√° xa
      if (distance > 10) {
        let moveX = (dx / distance) * supportTank.speed;
        let moveY = (dy / distance) * supportTank.speed;
        
        supportTank.worldX += moveX;
        supportTank.worldY += moveY;
      }
      
      // C·∫≠p nh·∫≠t v·ªã tr√≠ tr√™n m√†n h√¨nh
      supportTank.x = supportTank.worldX - worldSystem.offsetX;
      supportTank.y = supportTank.worldY - worldSystem.offsetY;
      
      // Xoay g√≥c theo ƒë·ªÉ t·∫°o chuy·ªÉn ƒë·ªông t·ª± nhi√™n
      supportTank.followAngle += 0.01;
      
      // B·∫Øn ƒë·∫°n h·ªó tr·ª£
      supportTank.shootCooldown--;
      if (supportTank.shootCooldown <= 0 && enemies.length > 0) {
        // T√¨m enemy g·∫ßn nh·∫•t ƒë·ªÉ b·∫Øn
        let closestEnemy = null;
        let closestDistance = Infinity;
        
        for (let enemy of enemies) {
          let dx = enemy.worldX - supportTank.worldX;
          let dy = enemy.worldY - supportTank.worldY;
          let distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < closestDistance) {
            closestDistance = distance;
            closestEnemy = enemy;
          }
        }
        
        // B·∫Øn v·ªÅ ph√≠a enemy g·∫ßn nh·∫•t
        if (closestEnemy && closestDistance < 400) { // Ch·ªâ b·∫Øn trong ph·∫°m vi 400px
          let dx = closestEnemy.worldX - supportTank.worldX;
          let dy = closestEnemy.worldY - supportTank.worldY;
          let distance = Math.sqrt(dx * dx + dy * dy);
          
          supportBullets.push({
            x: supportTank.x + 18, // Gi·ªØa xe tƒÉng nh·ªè
            y: supportTank.y,
            worldX: supportTank.worldX + 18,
            worldY: supportTank.worldY,
            dx: (dx / distance) * supportBulletSpeed,
            dy: (dy / distance) * supportBulletSpeed
          });
          
          supportTank.shootCooldown = supportTank.shootInterval;
        }
      }
    }

function update() {
  clear();
  
  // V·∫Ω b·∫£n ƒë·ªì v√¥ t·∫≠n
  drawTerrain();
  drawDecorations();
  
  // Hi·ªáu ·ª©ng n·ªï cho tank ng∆∞·ªùi ch∆°i
  if (typeof window.tankExplosions === 'undefined') window.tankExplosions = [];

  // Ki·ªÉm tra chi·∫øn th·∫Øng
  if (victorySystem.gameWon) {
    showVictoryScreen();
    return;
  }
  
  // N·∫øu ƒë√£ thua th√¨ v·∫Ω n·ªï v√† th√¥ng b√°o, kh√¥ng update n·ªØa
  if (tank.hp <= 0) {
    // V·∫Ω hi·ªáu ·ª©ng n·ªï nhi·ªÅu frame
    if (window.tankExplosions.length === 0) {
      for (let i = 0; i < 20; i++) {
        window.tankExplosions.push({ x: tank.x, y: tank.y, time: i * 2 });
      }
    }
    for (let i = window.tankExplosions.length - 1; i >= 0; i--) {
      let ex = window.tankExplosions[i];
      if (ex.time <= 30) drawExplosion(ex.x, ex.y);
      ex.time++;
      if (ex.time > 30) window.tankExplosions.splice(i, 1);
    }
    ctx.save();
    ctx.font = 'bold 2.2em Arial';
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'center';
    ctx.shadowColor = '#000';
    ctx.shadowBlur = 8;
    ctx.fillText('B·∫°n ƒë√£ thua tr√≤ ch∆°i', canvas.width / 2, canvas.height / 2);
    ctx.restore();
    // Hi·ªán n√∫t ch∆°i l·∫°i
    showReplayButton();
    return;
  }
  
  // Smooth tank movement v·ªõi h·ªá th·ªëng th·∫ø gi·ªõi v√¥ t·∫≠n
  let newWorldX = tank.worldX;
  let newWorldY = tank.worldY;
  let isMoving = false;
  let moveX = 0;
  let moveY = 0;
  
  if (keys['ArrowLeft']) {
    newWorldX -= tank.speed;
    moveX = -1;
    isMoving = true;
  }
  if (keys['ArrowRight']) {
    newWorldX += tank.speed;
    moveX = 1;
    isMoving = true;
  }
  if (keys['ArrowUp']) {
    newWorldY -= tank.speed;
    moveY = -1;
    isMoving = true;
  }
  if (keys['ArrowDown']) {
    newWorldY += tank.speed;
    moveY = 1;
    isMoving = true;
  }
  
  // C·∫≠p nh·∫≠t g√≥c xoay c·ªßa th√¢n xe tƒÉng d·ª±a tr√™n h∆∞·ªõng di chuy·ªÉn
  if (isMoving) {
    tank.angle = Math.atan2(moveY, moveX);
    
    // ƒêi·ªÅu ch·ªânh t·ªëc ƒë·ªô cho di chuy·ªÉn ch√©o ƒë·ªÉ tr√°nh di chuy·ªÉn nhanh h∆°n
    if (moveX !== 0 && moveY !== 0) {
      // Di chuy·ªÉn ch√©o, gi·∫£m t·ªëc ƒë·ªô xu·ªëng ‚àö2/2 ‚âà 0.707
      let diagonalSpeed = tank.speed * 0.707;
      tank.worldX = tank.worldX - (newWorldX - tank.worldX) + moveX * diagonalSpeed;
      tank.worldY = tank.worldY - (newWorldY - tank.worldY) + moveY * diagonalSpeed;
      newWorldX = tank.worldX;
      newWorldY = tank.worldY;
    }
  }
  
  // C·∫≠p nh·∫≠t v·ªã tr√≠ th·∫ø gi·ªõi
  tank.worldX = newWorldX;
  tank.worldY = newWorldY;
  
  // Gi·ªØ xe tƒÉng ·ªü trung t√¢m m√†n h√¨nh khi c√≥ th·ªÉ
  let targetScreenX = canvas.width / 2 - 30;
  let targetScreenY = canvas.height / 2 - 25;
  
  // C·∫≠p nh·∫≠t offset ƒë·ªÉ xe tƒÉng lu√¥n ·ªü gi·ªØa
  worldSystem.offsetX = tank.worldX - targetScreenX;
  worldSystem.offsetY = tank.worldY - targetScreenY;
  
  // C·∫≠p nh·∫≠t v·ªã tr√≠ xe tƒÉng tr√™n m√†n h√¨nh
  tank.x = tank.worldX - worldSystem.offsetX;
  tank.y = tank.worldY - worldSystem.offsetY;

  // C·∫≠p nh·∫≠t xe tƒÉng h·ªó tr·ª£
  updateSupportTank();

  // C·∫≠p nh·∫≠t t·ª± ƒë·ªông nh·∫Øm m·ª•c ti√™u
  if (tank.autoAim) {
    let nearestEnemy = findNearestEnemy(tank.x, tank.y);
    if (nearestEnemy) {
      // T√≠nh g√≥c nh·∫Øm ƒë·∫øn k·∫ª th√π g·∫ßn nh·∫•t
      let targetX = nearestEnemy.x + 30; // T√¢m k·∫ª th√π
      let targetY = nearestEnemy.y + 35;
      let tankCenterX = tank.x + 30; // T√¢m xe tƒÉng
      let tankCenterY = tank.y + 35;
      
      tank.turretAngle = calculateAimAngle(tankCenterX, tankCenterY, targetX, targetY);
    } else {
      // Kh√¥ng c√≥ k·∫ª th√π, nh·∫Øm th·∫≥ng l√™n
      tank.turretAngle = -Math.PI / 2;
    }
  }

  // C·∫≠p nh·∫≠t cooldown b·∫Øn ƒë·∫°n
  if (tank.shootCooldown > 0) {
    tank.shootCooldown--;
  }

  // B·∫Øn ƒë·∫°n (c√≥ th·ªÉ b·∫Øn trong khi di chuy·ªÉn)
  let shouldShoot = keys[' '] || (tank.autoShoot && findNearestEnemy(tank.x, tank.y) !== null);
  if (shouldShoot && tank.shootCooldown <= 0) {
    if (bulletTimeSystem.isActive) {
      // Khi laser ho·∫°t ƒë·ªông, ch·ªâ ƒë√°nh d·∫•u laser ƒëang b·∫Øn
      bulletTimeSystem.laserActive = true;
    } else {
      // T√≠nh v·ªã tr√≠ b·∫Øn t·ª´ ƒë·∫ßu n√≤ng ph√°o
      let barrelLength = 20;
      let barrelX = tank.x + 30 + Math.cos(tank.turretAngle) * barrelLength;
      let barrelY = tank.y + 35 + Math.sin(tank.turretAngle) * barrelLength;
      let worldBarrelX = tank.worldX + 30 + Math.cos(tank.turretAngle) * barrelLength;
      let worldBarrelY = tank.worldY + 35 + Math.sin(tank.turretAngle) * barrelLength;
      
      // B·∫Øn ƒë·∫°n theo h∆∞·ªõng nh·∫Øm
      bullets.push({ 
        x: barrelX, 
        y: barrelY, 
        worldX: worldBarrelX, 
        worldY: worldBarrelY,
        color: '#ffeb3b',
        isLaser: false,
        angle: tank.turretAngle // B·∫Øn theo g√≥c nh·∫Øm
      });
      
      tank.shootCooldown = tank.shootInterval;
      keys[' '] = false; // Ch·ªâ b·∫Øn m·ªôt vi√™n m·ªói l·∫ßn nh·∫•n
    }
  }
  
  // N·∫øu kh√¥ng nh·∫•n space, t·∫Øt laser
  if (!keys[' ']) {
    bulletTimeSystem.laserActive = false;
  }

  // C·∫≠p nh·∫≠t ƒë·∫°n c·ªßa ng∆∞·ªùi ch∆°i
  for (let i = bullets.length - 1; i >= 0; i--) {
    let bullet = bullets[i];
    
    // Di chuy·ªÉn ƒë·∫°n theo g√≥c b·∫Øn
    let speed = bulletSpeed;
    bullet.worldX += Math.cos(bullet.angle) * speed;
    bullet.worldY += Math.sin(bullet.angle) * speed;
    bullet.x = bullet.worldX - worldSystem.offsetX;
    bullet.y = bullet.worldY - worldSystem.offsetY;
    
    // X√≥a ƒë·∫°n n·∫øu ra kh·ªèi m√†n h√¨nh ho·∫∑c ƒëi qu√° xa
    if (bullet.x < -50 || bullet.x > canvas.width + 50 || 
        bullet.y < -50 || bullet.y > canvas.height + 50) {
      bullets.splice(i, 1);
    }
  }

  // C·∫≠p nh·∫≠t ƒë·∫°n c·ªßa xe tƒÉng h·ªó tr·ª£
  for (let i = supportBullets.length - 1; i >= 0; i--) {
    let bullet = supportBullets[i];
    bullet.worldX += bullet.dx;
    bullet.worldY += bullet.dy;
    bullet.x = bullet.worldX - worldSystem.offsetX;
    bullet.y = bullet.worldY - worldSystem.offsetY;
    
    // X√≥a ƒë·∫°n n·∫øu ra kh·ªèi m√†n h√¨nh
    if (bullet.x < -10 || bullet.x > canvas.width + 10 || 
        bullet.y < -10 || bullet.y > canvas.height + 10) {
      supportBullets.splice(i, 1);
    }
  }

  // Spawn enemies
  frameCount++;
  if (frameCount % enemySpawnInterval === 0) {
    spawnEnemy();
  }

  // C·∫≠p nh·∫≠t enemies
  for (let i = enemies.length - 1; i >= 0; i--) {
    let enemy = enemies[i];
    
    // C·∫≠p nh·∫≠t v·ªã tr√≠ th·∫ø gi·ªõi
    enemy.worldX += enemy.dx;
    enemy.worldY += enemy.dy;
    
    // C·∫≠p nh·∫≠t v·ªã tr√≠ tr√™n m√†n h√¨nh
    enemy.x = enemy.worldX - worldSystem.offsetX;
    enemy.y = enemy.worldY - worldSystem.offsetY;
    
    // ƒê·ªïi h∆∞·ªõng khi ch·∫°m bi√™n
    if (enemy.x <= 0 || enemy.x >= canvas.width - 60) {
      enemy.dx = -enemy.dx;
    }
    
    // X√≥a enemy n·∫øu ra kh·ªèi m√†n h√¨nh d∆∞·ªõi
    if (enemy.y > canvas.height + 100) {
      enemies.splice(i, 1);
      continue;
    }
    
    // Enemy b·∫Øn ƒë·∫°n ng·∫´u nhi√™n
    if (Math.random() < 0.01) {
      enemyBullets.push({ 
        x: enemy.x + 30, 
        y: enemy.y + 70,
        worldX: enemy.worldX + 30,
        worldY: enemy.worldY + 70
      });
    }
  }

  // C·∫≠p nh·∫≠t ƒë·∫°n c·ªßa enemy
  for (let i = enemyBullets.length - 1; i >= 0; i--) {
    let bullet = enemyBullets[i];
    bullet.worldY += enemyBulletSpeed;
    bullet.y = bullet.worldY - worldSystem.offsetY;
    
    // X√≥a ƒë·∫°n n·∫øu ra kh·ªèi m√†n h√¨nh
    if (bullet.y > canvas.height + 10) {
      enemyBullets.splice(i, 1);
    }
  }

  // Ki·ªÉm tra va ch·∫°m ƒë·∫°n ng∆∞·ªùi ch∆°i v·ªõi enemies
  for (let i = bullets.length - 1; i >= 0; i--) {
    for (let j = enemies.length - 1; j >= 0; j--) {
      let bullet = bullets[i];
      let enemy = enemies[j];
      
      if (bullet && enemy && 
          bullet.x > enemy.x && bullet.x < enemy.x + 60 &&
          bullet.y > enemy.y && bullet.y < enemy.y + 70) {
        
        // Gi·∫£m m√°u enemy
        enemy.hp--;
        
        // Th√™m hi·ªáu ·ª©ng n·ªï
        if (typeof window.explosions === 'undefined') window.explosions = [];
        window.explosions.push({ x: enemy.x, y: enemy.y, time: 0 });
        
        // X√≥a ƒë·∫°n
        bullets.splice(i, 1);
        
        // N·∫øu m√°u v·ªÅ 0 th√¨ th√™m hi·ªáu ·ª©ng n·ªï v√† x√≥a xe tƒÉng
        if (enemy.hp <= 0) {
          window.explosions.push({ x: enemy.x, y: enemy.y, time: 0 });
          enemies.splice(j, 1);
          
          // TƒÉng s·ªë qu√¢n ƒë·ªãch ƒë√£ ti√™u di·ªát
          victorySystem.enemiesKilled++;
          
          // Ki·ªÉm tra ƒëi·ªÅu ki·ªán chi·∫øn th·∫Øng
          if (victorySystem.enemiesKilled >= victorySystem.targetKills) {
            victorySystem.gameWon = true;
          }
        }
        break;
      }
    }
  }

  // Ki·ªÉm tra va ch·∫°m laser v·ªõi enemies
  if (bulletTimeSystem.isActive && bulletTimeSystem.laserActive) {
    const laserX = tank.x + 30;
    const laserWidth = 12; // ƒê·ªô r·ªông tia laser
    
    for (let j = enemies.length - 1; j >= 0; j--) {
      let enemy = enemies[j];
      
      // Ki·ªÉm tra n·∫øu enemy n·∫±m trong ƒë∆∞·ªùng laser (theo tr·ª•c X) v√† ph√≠a tr√™n xe tƒÉng (theo tr·ª•c Y)
      if (enemy.x < laserX + laserWidth/2 && enemy.x + 60 > laserX - laserWidth/2 && 
          enemy.y < tank.y) {
        
        // Gi·∫£m m√°u enemy li√™n t·ª•c (laser g√¢y s√°t th∆∞∆°ng cao)
        enemy.hp -= 0.2; // Gi·∫£m t·ª´ t·ª´ ƒë·ªÉ t·∫°o hi·ªáu ·ª©ng laser ƒë·ªët ch√°y
        
        // Th√™m hi·ªáu ·ª©ng n·ªï
        if (typeof window.explosions === 'undefined') window.explosions = [];
        if (Math.random() < 0.3) { // Hi·ªáu ·ª©ng n·ªï ng·∫´u nhi√™n
          window.explosions.push({ x: enemy.x + Math.random() * 60, y: enemy.y + Math.random() * 70, time: 0 });
        }
        
        // N·∫øu m√°u v·ªÅ 0 th√¨ th√™m hi·ªáu ·ª©ng n·ªï l·ªõn v√† x√≥a xe tƒÉng
        if (enemy.hp <= 0) {
          window.explosions.push({ x: enemy.x, y: enemy.y, time: 0 });
          enemies.splice(j, 1);
          
          // TƒÉng s·ªë qu√¢n ƒë·ªãch ƒë√£ ti√™u di·ªát
          victorySystem.enemiesKilled++;
          
          // Ki·ªÉm tra ƒëi·ªÅu ki·ªán chi·∫øn th·∫Øng
          if (victorySystem.enemiesKilled >= victorySystem.targetKills) {
            victorySystem.gameWon = true;
          }
        }
      }
    }
  }

  // Ki·ªÉm tra va ch·∫°m ƒë·∫°n xe tƒÉng h·ªó tr·ª£ v·ªõi enemies
  for (let i = supportBullets.length - 1; i >= 0; i--) {
    for (let j = enemies.length - 1; j >= 0; j--) {
      let bullet = supportBullets[i];
      let enemy = enemies[j];
      
      if (bullet && enemy && 
          bullet.x > enemy.x && bullet.x < enemy.x + 60 &&
          bullet.y > enemy.y && bullet.y < enemy.y + 70) {
        
        // Gi·∫£m m√°u enemy (ƒë·∫°n h·ªó tr·ª£ g√¢y √≠t s√°t th∆∞∆°ng h∆°n)
        enemy.hp--;
        
        // Th√™m hi·ªáu ·ª©ng n·ªï
        if (typeof window.explosions === 'undefined') window.explosions = [];
        window.explosions.push({ x: enemy.x, y: enemy.y, time: 0 });
        
        // X√≥a ƒë·∫°n
        supportBullets.splice(i, 1);
        
        // N·∫øu m√°u v·ªÅ 0 th√¨ th√™m hi·ªáu ·ª©ng n·ªï v√† x√≥a xe tƒÉng
        if (enemy.hp <= 0) {
          window.explosions.push({ x: enemy.x, y: enemy.y, time: 0 });
          enemies.splice(j, 1);
          
          // TƒÉng s·ªë qu√¢n ƒë·ªãch ƒë√£ ti√™u di·ªát
          victorySystem.enemiesKilled++;
          
          // Ki·ªÉm tra ƒëi·ªÅu ki·ªán chi·∫øn th·∫Øng
          if (victorySystem.enemiesKilled >= victorySystem.targetKills) {
            victorySystem.gameWon = true;
          }
        }
        break;
      }
    }
  }

  // Ki·ªÉm tra va ch·∫°m ƒë·∫°n enemy v·ªõi tank ng∆∞·ªùi ch∆°i
  for (let i = enemyBullets.length - 1; i >= 0; i--) {
    let bullet = enemyBullets[i];
    
    if (bullet.x > tank.x && bullet.x < tank.x + 60 &&
        bullet.y > tank.y && bullet.y < tank.y + 70) {
      
      // Gi·∫£m m√°u tank
      tank.hp--;
      
      // Th√™m hi·ªáu ·ª©ng n·ªï khi tank b·ªã tr√∫ng
      if (typeof window.tankHitExplosions === 'undefined') window.tankHitExplosions = [];
      window.tankHitExplosions.push({ x: tank.x, y: tank.y, time: 0 });
      
      // X√≥a ƒë·∫°n
      enemyBullets.splice(i, 1);
    }
  }

  // Ki·ªÉm tra va ch·∫°m ƒë·∫°n enemy v·ªõi xe tƒÉng h·ªó tr·ª£
  for (let i = enemyBullets.length - 1; i >= 0; i--) {
    let bullet = enemyBullets[i];
    
    if (supportTank.hp > 0 && 
        bullet.x > supportTank.x && bullet.x < supportTank.x + 36 &&
        bullet.y > supportTank.y && bullet.y < supportTank.y + 42) {
      
      // Gi·∫£m m√°u xe tƒÉng h·ªó tr·ª£
      supportTank.hp--;
      
      // Th√™m hi·ªáu ·ª©ng n·ªï khi xe tƒÉng h·ªó tr·ª£ b·ªã tr√∫ng
      if (typeof window.supportTankHitExplosions === 'undefined') window.supportTankHitExplosions = [];
      window.supportTankHitExplosions.push({ x: supportTank.x, y: supportTank.y, time: 0 });
      
      // X√≥a ƒë·∫°n
      enemyBullets.splice(i, 1);
    }
  }

  // V·∫Ω hi·ªáu ·ª©ng n·ªï khi tank b·ªã tr√∫ng
  if (typeof window.tankHitExplosions !== 'undefined') {
    for (let i = window.tankHitExplosions.length - 1; i >= 0; i--) {
      let ex = window.tankHitExplosions[i];
      if (ex.time <= 15) drawExplosion(ex.x, ex.y);
      ex.time++;
      if (ex.time > 15) window.tankHitExplosions.splice(i, 1);
    }
  }

  // V·∫Ω hi·ªáu ·ª©ng n·ªï khi xe tƒÉng h·ªó tr·ª£ b·ªã tr√∫ng
  if (typeof window.supportTankHitExplosions !== 'undefined') {
    for (let i = window.supportTankHitExplosions.length - 1; i >= 0; i--) {
      let ex = window.supportTankHitExplosions[i];
      if (ex.time <= 15) drawExplosion(ex.x, ex.y);
      ex.time++;
      if (ex.time > 15) window.supportTankHitExplosions.splice(i, 1);
    }
  }

  // V·∫Ω tank ng∆∞·ªùi ch∆°i (ch·ªâ khi c√≤n s·ªëng)
  if (tank.hp > 0) {
    drawTank(tank.x, tank.y, '#4caf50', '#388e3c', false, tank.hp, tank.maxHp, tank.angle, tank.turretAngle);
    
    // V·∫Ω ƒë∆∞·ªùng ch·ªâ b√°o h∆∞·ªõng nh·∫Øm (ch·ªâ khi t·ª± ƒë·ªông nh·∫Øm b·∫≠t)
    if (tank.autoAim) {
      let nearestEnemy = findNearestEnemy(tank.x, tank.y);
      if (nearestEnemy) {
        ctx.save();
        ctx.strokeStyle = '#ff5722';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]); // ƒê∆∞·ªùng ƒë·ª©t n√©t
        ctx.beginPath();
        ctx.moveTo(tank.x + 30, tank.y + 35);
        ctx.lineTo(nearestEnemy.x + 30, nearestEnemy.y + 35);
        ctx.stroke();
        ctx.setLineDash([]); // Reset v·ªÅ ƒë∆∞·ªùng li·ªÅn n√©t
        ctx.restore();
      }
    }
  }

  // V·∫Ω xe tƒÉng h·ªó tr·ª£ (ch·ªâ khi c√≤n s·ªëng)
  if (supportTank.hp > 0) {
    drawSupportTank(supportTank.x, supportTank.y, '#2196f3', '#1976d2', supportTank.hp, supportTank.maxHp);
  }

  // V·∫Ω enemies
  for (let enemy of enemies) {
    drawTank(enemy.x, enemy.y, '#f44336', '#d32f2f', true, enemy.hp, enemy.maxHp);
  }

  // V·∫Ω tia laser n·∫øu ƒëang ho·∫°t ƒë·ªông
  if (bulletTimeSystem.isActive && bulletTimeSystem.laserActive) {
    drawLaser({ x: tank.x + 30, y: tank.y });
  }

  // V·∫Ω ƒë·∫°n c·ªßa ng∆∞·ªùi ch∆°i
  for (let bullet of bullets) {
    drawBullet(bullet, bullet.color || '#ffeb3b');
  }

  // V·∫Ω ƒë·∫°n c·ªßa xe tƒÉng h·ªó tr·ª£
  for (let bullet of supportBullets) {
    drawBullet(bullet, '#2196f3');
  }

  // V·∫Ω ƒë·∫°n c·ªßa enemy
  for (let bullet of enemyBullets) {
    drawBullet(bullet, '#f44336');
  }

  // V·∫Ω hi·ªáu ·ª©ng n·ªï
  if (typeof window.explosions !== 'undefined') {
    for (let i = window.explosions.length - 1; i >= 0; i--) {
      let ex = window.explosions[i];
      if (ex.time <= 30) drawExplosion(ex.x, ex.y);
      ex.time++;
      if (ex.time > 30) window.explosions.splice(i, 1);
    }
  }

  // C·∫≠p nh·∫≠t v√† v·∫Ω s√≥ng ƒëi·ªán
  for (let i = electricWaveSystem.waves.length - 1; i >= 0; i--) {
    let wave = electricWaveSystem.waves[i];
    
    // C·∫≠p nh·∫≠t v·ªã tr√≠ s√≥ng tr√™n m√†n h√¨nh
    wave.x = wave.worldX - worldSystem.offsetX;
    wave.y = wave.worldY - worldSystem.offsetY;
    
    // TƒÉng b√°n k√≠nh s√≥ng
    wave.radius += wave.speed;
    
    // Gi·∫£m ƒë·ªô trong su·ªët theo th·ªùi gian
    wave.opacity = Math.max(0, 1 - (wave.radius / wave.maxRadius));
    
    // Ki·ªÉm tra va ch·∫°m v·ªõi k·∫ª ƒë·ªãch
    for (let j = enemies.length - 1; j >= 0; j--) {
      let enemy = enemies[j];
      
      // Ki·ªÉm tra xem k·∫ª ƒë·ªãch ƒë√£ b·ªã tr√∫ng ch∆∞a
      if (wave.hitEnemies.includes(enemy.id)) continue;
      
      // T√≠nh kho·∫£ng c√°ch t·ª´ t√¢m s√≥ng ƒë·∫øn k·∫ª ƒë·ªãch
      let dx = enemy.x + 30 - wave.x;
      let dy = enemy.y + 35 - wave.y;
      let distance = Math.sqrt(dx * dx + dy * dy);
      
      // N·∫øu k·∫ª ƒë·ªãch n·∫±m trong ph·∫°m vi s√≥ng
      if (distance <= wave.radius && distance >= wave.radius - wave.speed * 2) {
        // G√¢y s√°t th∆∞∆°ng
        enemy.hp -= wave.damage;
        
        // Th√™m hi·ªáu ·ª©ng n·ªï ƒëi·ªán
        if (typeof window.electricExplosions === 'undefined') window.electricExplosions = [];
        window.electricExplosions.push({ x: enemy.x, y: enemy.y, time: 0 });
        
        // ƒê√°nh d·∫•u k·∫ª ƒë·ªãch ƒë√£ b·ªã tr√∫ng
        wave.hitEnemies.push(enemy.id);
        
        // N·∫øu k·∫ª ƒë·ªãch ch·∫øt
        if (enemy.hp <= 0) {
          if (typeof window.explosions === 'undefined') window.explosions = [];
          window.explosions.push({ x: enemy.x, y: enemy.y, time: 0 });
          enemies.splice(j, 1);
          
          // TƒÉng s·ªë qu√¢n ƒë·ªãch ƒë√£ ti√™u di·ªát
          victorySystem.enemiesKilled++;
          
          // Ki·ªÉm tra ƒëi·ªÅu ki·ªán chi·∫øn th·∫Øng
          if (victorySystem.enemiesKilled >= victorySystem.targetKills) {
            victorySystem.gameWon = true;
          }
        }
      }
    }
    
    // V·∫Ω s√≥ng ƒëi·ªán
    if (wave.x > -wave.maxRadius && wave.x < canvas.width + wave.maxRadius && 
        wave.y > -wave.maxRadius && wave.y < canvas.height + wave.maxRadius) {
      drawElectricWave(wave);
    }
    
    // X√≥a s√≥ng khi ƒë√£ h·∫øt hi·ªáu l·ª±c
    if (wave.radius >= wave.maxRadius) {
      electricWaveSystem.waves.splice(i, 1);
    }
  }

  // V·∫Ω hi·ªáu ·ª©ng n·ªï ƒëi·ªán
  if (typeof window.electricExplosions !== 'undefined') {
    for (let i = window.electricExplosions.length - 1; i >= 0; i--) {
      let ex = window.electricExplosions[i];
      if (ex.time <= 20) {
        // V·∫Ω hi·ªáu ·ª©ng n·ªï ƒëi·ªán
        ctx.save();
        ctx.beginPath();
        ctx.arc(ex.x + 30, ex.y + 35, 15 + ex.time, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(138, 43, 226, ${1 - ex.time / 20})`;
        ctx.lineWidth = 3;
        ctx.stroke();
        
        // V·∫Ω tia ch·ªõp nh·ªè
        for (let j = 0; j < 6; j++) {
          let angle = (j / 6) * Math.PI * 2 + ex.time * 0.2;
          let radius = 10 + ex.time * 0.5;
          ctx.beginPath();
          ctx.moveTo(ex.x + 30, ex.y + 35);
          ctx.lineTo(
            ex.x + 30 + Math.cos(angle) * radius,
            ex.y + 35 + Math.sin(angle) * radius
          );
          ctx.strokeStyle = `rgba(255, 255, 255, ${1 - ex.time / 20})`;
          ctx.lineWidth = 2;
          ctx.stroke();
        }
        ctx.restore();
      }
      ex.time++;
      if (ex.time > 20) window.electricExplosions.splice(i, 1);
    }
  }

  // C·∫≠p nh·∫≠t cooldown s√≥ng ƒëi·ªán
  if (!electricWaveSystem.isReady) {
    electricWaveSystem.currentCooldown -= 16.67; // Gi·∫£ s·ª≠ 60 FPS
    if (electricWaveSystem.currentCooldown <= 0) {
      electricWaveSystem.isReady = true;
      updateElectricWaveButton();
    }
  }
  
  // C·∫≠p nh·∫≠t cooldown b√¨nh nhi√™n li·ªáu
  if (!fuelSystem.isReady) {
    fuelSystem.currentCooldown -= 16.67; // Gi·∫£ s·ª≠ 60 FPS
    if (fuelSystem.currentCooldown <= 0) {
      fuelSystem.isReady = true;
      updateFuelButton();
    }
  }
  
  // C·∫≠p nh·∫≠t B·∫Øn laser
  if (bulletTimeSystem.isActive) {
    bulletTimeSystem.currentDuration -= 16.67; // Gi·∫£ s·ª≠ 60 FPS
    if (bulletTimeSystem.currentDuration <= 0) {
      // K·∫øt th√∫c B·∫Øn laser
      bulletTimeSystem.isActive = false;
      bulletTimeSystem.currentCooldown = bulletTimeSystem.cooldownTime;
      
      // Kh√¥i ph·ª•c th·ªùi gian b·∫Øn g·ªëc (kh√¥ng c·∫ßn l√†m g√¨ v√¨ logic b·∫Øn t·ª± x·ª≠ l√Ω)
      
      updateBulletTimeButton();
      showBulletTimeMessage("üî¥ B·∫Øn laser k·∫øt th√∫c!");
    }
  } else if (!bulletTimeSystem.isReady) {
    bulletTimeSystem.currentCooldown -= 16.67; // Gi·∫£ s·ª≠ 60 FPS
    if (bulletTimeSystem.currentCooldown <= 0) {
      bulletTimeSystem.isReady = true;
      updateBulletTimeButton();
    }
  }

  // C·∫≠p nh·∫≠t v√† v·∫Ω t√™n l·ª≠a
  for (let i = missileSystem.missiles.length - 1; i >= 0; i--) {
    let missile = missileSystem.missiles[i];
    
    // C·∫≠p nh·∫≠t v·ªã tr√≠ t√™n l·ª≠a tr√™n m√†n h√¨nh
    missile.x = missile.worldX - worldSystem.offsetX;
    missile.y = missile.worldY - worldSystem.offsetY;
    
    // T√¨m m·ª•c ti√™u g·∫ßn nh·∫•t n·∫øu ch∆∞a c√≥
    if (!missile.target) {
      let closestDistance = missileSystem.homingRange;
      let closestEnemy = null;
      
      for (let enemy of enemies) {
        let dx = enemy.worldX + 30 - missile.worldX;
        let dy = enemy.worldY + 35 - missile.worldY;
        let distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < closestDistance) {
          closestDistance = distance;
          closestEnemy = enemy;
        }
      }
      
      missile.target = closestEnemy;
    }
    
    // C·∫≠p nh·∫≠t h∆∞·ªõng bay c·ªßa t√™n l·ª≠a
    if (missile.target) {
      let dx = missile.target.worldX + 30 - missile.worldX;
      let dy = missile.target.worldY + 35 - missile.worldY;
      let distance = Math.sqrt(dx * dx + dy * dy);
      
      if (distance > 0) {
        // T√≠nh h∆∞·ªõng m·ªõi
        let targetVx = (dx / distance) * missileSystem.missileSpeed;
        let targetVy = (dy / distance) * missileSystem.missileSpeed;
        
        // L√†m m∆∞·ª£t chuy·ªÉn h∆∞·ªõng
        missile.vx += (targetVx - missile.vx) * 0.1;
        missile.vy += (targetVy - missile.vy) * 0.1;
      }
    }
    
    // C·∫≠p nh·∫≠t v·ªã tr√≠ th·∫ø gi·ªõi
    missile.worldX += missile.vx;
    missile.worldY += missile.vy;
    
    // Th√™m ƒëi·ªÉm v√†o ƒëu√¥i kh√≥i
    missile.trailPoints.push({ x: missile.x, y: missile.y });
    if (missile.trailPoints.length > 10) {
      missile.trailPoints.shift();
    }
    
    // Ki·ªÉm tra va ch·∫°m v·ªõi k·∫ª ƒë·ªãch
    let hasHit = false;
    for (let j = enemies.length - 1; j >= 0; j--) {
      let enemy = enemies[j];
      let dx = enemy.x + 30 - missile.x;
      let dy = enemy.y + 35 - missile.y;
      let distance = Math.sqrt(dx * dx + dy * dy);
      
      if (distance < 30) { // Va ch·∫°m tr·ª±c ti·∫øp
        hasHit = true;
        
        // T·∫°o v·ª• n·ªï
        if (typeof window.missileExplosions === 'undefined') window.missileExplosions = [];
        window.missileExplosions.push({
          x: missile.x,
          y: missile.y,
          radius: 0,
          maxRadius: missileSystem.explosionRadius,
          time: 0,
          maxTime: 30
        });
        
        // G√¢y s√°t th∆∞∆°ng cho t·∫•t c·∫£ k·∫ª ƒë·ªãch trong ph·∫°m vi n·ªï
        for (let k = enemies.length - 1; k >= 0; k--) {
          let targetEnemy = enemies[k];
          let explosionDx = targetEnemy.x + 30 - missile.x;
          let explosionDy = targetEnemy.y + 35 - missile.y;
          let explosionDistance = Math.sqrt(explosionDx * explosionDx + explosionDy * explosionDy);
          
          if (explosionDistance <= missileSystem.explosionRadius) {
            targetEnemy.hp -= missileSystem.missileDamage;
            
            // Th√™m hi·ªáu ·ª©ng n·ªï cho t·ª´ng k·∫ª ƒë·ªãch b·ªã tr√∫ng
            if (typeof window.explosions === 'undefined') window.explosions = [];
            window.explosions.push({ x: targetEnemy.x, y: targetEnemy.y, time: 0 });
            
            if (targetEnemy.hp <= 0) {
              enemies.splice(k, 1);
              victorySystem.enemiesKilled++;
              
              if (victorySystem.enemiesKilled >= victorySystem.targetKills) {
                victorySystem.gameWon = true;
              }
            }
          }
        }
        
        break;
      }
    }
    
    // X√≥a t√™n l·ª≠a n·∫øu ra kh·ªèi m√†n h√¨nh ho·∫∑c ƒë√£ n·ªï
    if (hasHit || missile.y < -50 || missile.y > canvas.height + 50 || 
        missile.x < -50 || missile.x > canvas.width + 50) {
      missileSystem.missiles.splice(i, 1);
      continue;
    }
    
    // V·∫Ω t√™n l·ª≠a
    if (missile.x > -50 && missile.x < canvas.width + 50 && 
        missile.y > -50 && missile.y < canvas.height + 50) {
      drawMissile(missile);
    }
  }

  // V·∫Ω hi·ªáu ·ª©ng n·ªï t√™n l·ª≠a
  if (typeof window.missileExplosions !== 'undefined') {
    for (let i = window.missileExplosions.length - 1; i >= 0; i--) {
      let ex = window.missileExplosions[i];
      
      // TƒÉng b√°n k√≠nh n·ªï
      ex.radius = (ex.time / ex.maxTime) * ex.maxRadius;
      let opacity = 1 - (ex.time / ex.maxTime);
      
      if (ex.time <= ex.maxTime) {
        drawMissileExplosion(ex.x, ex.y, ex.radius, opacity);
      }
      
      ex.time++;
      if (ex.time > ex.maxTime) {
        window.missileExplosions.splice(i, 1);
      }
    }
  }

  // C·∫≠p nh·∫≠t cooldown t√™n l·ª≠a
  if (!missileSystem.isReady) {
    missileSystem.currentCooldown -= 16.67; // Gi·∫£ s·ª≠ 60 FPS
    if (missileSystem.currentCooldown <= 0) {
      missileSystem.isReady = true;
      updateMissileButton();
    }
  }

  // Hi·ªÉn th·ªã th√¥ng tin game
  ctx.save();
  ctx.font = 'bold 1.2em Arial';
  ctx.fillStyle = '#fff';
  ctx.shadowColor = '#000';
  ctx.shadowBlur = 3;
  ctx.fillText(`HP: ${tank.hp}/${tank.maxHp}`, 20, 20);
  ctx.fillText(`Ti√™u di·ªát: ${victorySystem.enemiesKilled}/${victorySystem.targetKills}`, 20, 40);
  
  // Hi·ªÉn th·ªã cooldown b√¨nh nhi√™n li·ªáu
  if (!fuelSystem.isReady) {
    let cooldownSeconds = Math.ceil(fuelSystem.currentCooldown / 1000);
    ctx.fillStyle = '#4caf50';
    ctx.fillText(`‚õΩ Nhi√™n li·ªáu: ${cooldownSeconds}s`, 20, 60);
  } else {
    ctx.fillStyle = '#4caf50';
    ctx.fillText(`‚õΩ Nhi√™n li·ªáu: S·∫µn s√†ng`, 20, 60);
  }
  
  // Hi·ªÉn th·ªã th√¥ng b√°o fuel
  if (fuelMessage.time > 0) {
    ctx.fillStyle = '#4caf50';
    ctx.fillText(fuelMessage.text, 20, 80);
    fuelMessage.time--;
  }
  
  // Hi·ªÉn th·ªã th√¥ng b√°o b·∫Øn laser
  if (bulletTimeMessage.time > 0) {
    ctx.fillStyle = '#2196f3';
    ctx.fillText(bulletTimeMessage.text, 20, 160);
    bulletTimeMessage.time--;
  }
  
  // Hi·ªÉn th·ªã th√¥ng b√°o chung
  if (generalMessage.time > 0) {
    ctx.fillStyle = '#ffeb3b';
    ctx.fillText(generalMessage.text, 20, 180);
    generalMessage.time--;
  }
  
  // Hi·ªÉn th·ªã tr·∫°ng th√°i t·ª± ƒë·ªông nh·∫Øm v√† b·∫Øn t·ª± ƒë·ªông
  ctx.fillStyle = tank.autoAim ? '#4caf50' : '#f44336';
  ctx.fillText(`üéØ T·ª± ƒë·ªông nh·∫Øm: ${tank.autoAim ? 'B·∫¨T' : 'T·∫ÆT'} (A)`, 20, 200);
  
  ctx.fillStyle = tank.autoShoot ? '#4caf50' : '#f44336';
  ctx.fillText(`üî´ B·∫Øn t·ª± ƒë·ªông: ${tank.autoShoot ? 'B·∫¨T' : 'T·∫ÆT'} (Z)`, 20, 220);
  
  // Hi·ªÉn th·ªã cooldown s√≥ng ƒëi·ªán
  if (!electricWaveSystem.isReady) {
    let cooldownSeconds = Math.ceil(electricWaveSystem.currentCooldown / 1000);
    ctx.fillStyle = '#8a2be2';
    ctx.fillText(`‚ö° S√≥ng ƒëi·ªán: ${cooldownSeconds}s`, 20, 100);
  } else {
    ctx.fillStyle = '#8a2be2';
    ctx.fillText(`‚ö° S√≥ng ƒëi·ªán: S·∫µn s√†ng`, 20, 100);
  }
  
  // Hi·ªÉn th·ªã cooldown t√™n l·ª≠a
  if (!missileSystem.isReady) {
    let cooldownSeconds = Math.ceil(missileSystem.currentCooldown / 1000);
    ctx.fillStyle = '#ff5722';
    ctx.fillText(`üöÄ T√™n l·ª≠a: ${cooldownSeconds}s`, 20, 120);
  } else {
    ctx.fillStyle = '#ff5722';
    ctx.fillText(`üöÄ T√™n l·ª≠a: S·∫µn s√†ng`, 20, 120);
  }
  
  // Hi·ªÉn th·ªã tr·∫°ng th√°i B·∫Øn laser
  if (bulletTimeSystem.isActive) {
    let durationSeconds = Math.ceil(bulletTimeSystem.currentDuration / 1000);
    ctx.fillStyle = '#2196f3';
    ctx.fillText(`üî¥ B·∫Øn laser: ${durationSeconds}s`, 20, 140);
  } else if (!bulletTimeSystem.isReady) {
    let cooldownSeconds = Math.ceil(bulletTimeSystem.currentCooldown / 1000);
    ctx.fillStyle = '#2196f3';
    ctx.fillText(`üî¥ B·∫Øn laser: ${cooldownSeconds}s`, 20, 140);
  } else {
    ctx.fillStyle = '#2196f3';
    ctx.fillText(`üî¥ B·∫Øn laser: S·∫µn s√†ng`, 20, 140);
  }
  ctx.restore();

  // C·∫≠p nh·∫≠t tr·∫°ng th√°i n√∫t b√¨nh nhi√™n li·ªáu
  updateFuelButton();
  
  // H·ªá th·ªëng b√¨nh nhi√™n li·ªáu - th·ªùi gian ch·ªù 3 gi√¢y
}

// Th√™m n√∫t ch∆°i l·∫°i
function showReplayButton() {
  let btn = document.getElementById('replayBtn');
  if (!btn) {
    btn = document.createElement('button');
    btn.id = 'replayBtn';
    btn.innerText = 'Ch∆°i l·∫°i';
    btn.style.position = 'fixed';
    btn.style.top = 'calc(50% + 60px)';
    btn.style.left = '50%';
    btn.style.transform = 'translate(-50%,0)';
    btn.style.fontSize = '2em';
    btn.style.padding = '0.5em 2em';
    btn.style.zIndex = '100';
    btn.style.background = '#2196f3';
    btn.style.color = '#fff';
    btn.style.border = 'none';
    btn.style.borderRadius = '15px';
    btn.style.boxShadow = '0 4px 15px rgba(0,0,0,0.3)';
    btn.style.cursor = 'pointer';
    document.body.appendChild(btn);
    btn.addEventListener('click', function() {
      // Reset tr·∫°ng th√°i game
      resetGame();
      btn.remove();
    });
  }
  btn.style.display = 'block';
}

// Hi·ªÉn th·ªã m√†n h√¨nh chi·∫øn th·∫Øng
function showVictoryScreen() {
  // Hi·ªáu ·ª©ng ph√°o hoa (c√≥ th·ªÉ th√™m sau)
  ctx.save();
  ctx.font = 'bold 3em Arial';
  ctx.fillStyle = '#FFD700';
  ctx.textAlign = 'center';
  ctx.shadowColor = '#000';
  ctx.shadowBlur = 10;
  ctx.fillText('üéâ CHI·∫æN TH·∫ÆNG! üéâ', canvas.width / 2, canvas.height / 2 - 50);
  
  ctx.font = 'bold 1.5em Arial';
  ctx.fillStyle = '#fff';
  ctx.fillText(`ƒê√£ ti√™u di·ªát ${victorySystem.targetKills} qu√¢n ƒë·ªãch!`, canvas.width / 2, canvas.height / 2 + 20);
  ctx.restore();
  
  // Hi·ªán n√∫t ch∆°i l·∫°i
  showReplayButton();
}

function resetGame() {
  // Reset c√°c bi·∫øn game
  tank.hp = tank.maxHp;
  tank.x = canvas.width/2 - 30;
  tank.y = canvas.height - 120;
  if (typeof tank.worldX !== 'undefined') tank.worldX = 0;
  if (typeof tank.worldY !== 'undefined') tank.worldY = 0;
  bullets = [];
  enemyBullets = [];
  enemies = [];
  window.explosions = [];
  window.tankExplosions = [];
  window.tankHitExplosions = [];
  window.electricExplosions = [];
  window.missileExplosions = [];
  frameCount = 0;
  enemyIdCounter = 0;
  gameStarted = true;
  
  // Reset h·ªá th·ªëng b√¨nh nhi√™n li·ªáu
  fuelSystem.isReady = true;
  fuelSystem.currentCooldown = 0;
  updateFuelButton();
  
  // Reset h·ªá th·ªëng s√≥ng ƒëi·ªán
  electricWaveSystem.isReady = true;
  electricWaveSystem.currentCooldown = 0;
  electricWaveSystem.waves = [];
  updateElectricWaveButton();
  
  // Reset h·ªá th·ªëng t√™n l·ª≠a - lu√¥n s·∫µn s√†ng
  missileSystem.isReady = true;
  missileSystem.currentCooldown = 0;
  missileSystem.missiles = [];
  updateMissileButton();
  
  // Reset h·ªá th·ªëng B·∫Øn laser
  bulletTimeSystem.isActive = false;
  bulletTimeSystem.isReady = true;
  bulletTimeSystem.currentDuration = 0;
  bulletTimeSystem.currentCooldown = 0;
  updateBulletTimeButton();
  
  // Reset h·ªá th·ªëng chi·∫øn th·∫Øng
  victorySystem.enemiesKilled = 0;
  victorySystem.gameWon = false;
  // ·∫®n n√∫t replay n·∫øu c√≤n
  let btn = document.getElementById('replayBtn');
  if (btn) btn.style.display = 'none';
  // B·∫≠t l·∫°i controls n·∫øu c√≥
  if (joystickContainer) joystickContainer.style.display = 'block';
  if (shootControls) shootControls.style.display = 'block';
  // B·∫≠t l·∫°i nh·∫°c
  bgm.currentTime = 0;
  bgm.play();
  // Ch·∫°y l·∫°i game loop
  requestAnimationFrame(gameLoop);
}

    // X·ª≠ l√Ω ph√≠m m≈©i t√™n v√† b·∫Øn ƒë·∫°n
    // Smooth movement and shooting with key state
    const keys = {};
    document.addEventListener('keydown', function(e) {
      keys[e.key] = true;
      
      // Ph√≠m F ƒë·ªÉ s·ª≠ d·ª•ng b√¨nh nhi√™n li·ªáu
      if (e.key === 'f' || e.key === 'F') {
        useFuel();
      }
      
      // Ph√≠m E ƒë·ªÉ s·ª≠ d·ª•ng s√≥ng ƒëi·ªán
      if (e.key === 'e' || e.key === 'E') {
        useElectricWave();
      }
      
      // Ph√≠m s·ªë 1 ƒë·ªÉ s·ª≠ d·ª•ng t√™n l·ª≠a
      if (e.key === '1') {
        useMissile();
      }
      
      // Ph√≠m T ƒë·ªÉ s·ª≠ d·ª•ng ƒê·∫°n th·ªùi gian
      if (e.key === 't' || e.key === 'T') {
        useBulletTime();
      }
      
      // Ph√≠m A ƒë·ªÉ b·∫≠t/t·∫Øt t·ª± ƒë·ªông nh·∫Øm
      if (e.key === 'a' || e.key === 'A') {
        tank.autoAim = !tank.autoAim;
        showMessage(tank.autoAim ? "üéØ T·ª± ƒë·ªông nh·∫Øm: B·∫¨T" : "üéØ T·ª± ƒë·ªông nh·∫Øm: T·∫ÆT");
      }
      
      // Ph√≠m Z ƒë·ªÉ b·∫≠t/t·∫Øt b·∫Øn t·ª± ƒë·ªông
      if (e.key === 'z' || e.key === 'Z') {
        tank.autoShoot = !tank.autoShoot;
        showMessage(tank.autoShoot ? "üî´ B·∫Øn t·ª± ƒë·ªông: B·∫¨T" : "üî´ B·∫Øn t·ª± ƒë·ªông: T·∫ÆT");
      }
    });
    document.addEventListener('keyup', function(e) {
      keys[e.key] = false;
    });

    // H·ªá th·ªëng b√¨nh nhi√™n li·ªáu
    const fuelSystem = {
      isReady: true,
      cooldownTime: 3000, // 3 gi√¢y th·ªùi gian ch·ªù
      currentCooldown: 0
    };

    function useFuel() {
      if (fuelSystem.isReady) {
        let fuelUsed = false;
        
        // ∆Øu ti√™n b∆°m cho xe tƒÉng ch√≠nh tr∆∞·ªõc
        if (tank.hp < tank.maxHp) {
          tank.hp = Math.min(tank.hp + 2, tank.maxHp); // H·ªìi 2 m√°u cho xe tƒÉng ch√≠nh
          // Hi·ªÉn th·ªã th√¥ng b√°o ng·∫Øn
          showFuelMessage("B∆°m m√°u xe tƒÉng ch√≠nh +2 ‚ù§Ô∏è");
          fuelUsed = true;
        }
        // N·∫øu xe tƒÉng ch√≠nh ƒë√£ ƒë·∫ßy m√°u, b∆°m cho xe tƒÉng nh·ªè
        else if (supportTank.hp > 0 && supportTank.hp < supportTank.maxHp) {
          supportTank.hp = Math.min(supportTank.hp + 2, supportTank.maxHp); // H·ªìi 2 m√°u cho xe tƒÉng nh·ªè
          // Hi·ªÉn th·ªã th√¥ng b√°o ng·∫Øn
          showFuelMessage("B∆°m m√°u xe tƒÉng nh·ªè +2 üíô");
          fuelUsed = true;
        }
        
        // N·∫øu ƒë√£ s·ª≠ d·ª•ng fuel, b·∫Øt ƒë·∫ßu th·ªùi gian ch·ªù
        if (fuelUsed) {
          fuelSystem.isReady = false;
          fuelSystem.currentCooldown = fuelSystem.cooldownTime;
        }
        
        updateFuelButton();
      }
    }

    // H·ªá th·ªëng th√¥ng b√°o fuel
    let fuelMessage = { text: '', time: 0 };
    
    function showFuelMessage(text) {
      fuelMessage.text = text;
      fuelMessage.time = 60; // Hi·ªÉn th·ªã trong 60 frames (1 gi√¢y)
    }
    
    function updateFuelButton() {
      // Ki·ªÉm tra xem c√≥ th·ªÉ b∆°m cho xe tƒÉng ch√≠nh ho·∫∑c xe tƒÉng nh·ªè kh√¥ng
      const canRefuelMainTank = tank.hp < tank.maxHp;
      const canRefuelSupportTank = supportTank.hp > 0 && supportTank.hp < supportTank.maxHp;
      
      if (fuelSystem.isReady && (canRefuelMainTank || canRefuelSupportTank)) {
        fuelBtn.classList.remove('disabled');
        fuelBtn.style.opacity = '1';
      } else {
        fuelBtn.classList.add('disabled');
        fuelBtn.style.opacity = '0.5';
      }
    }

    // H·ªá th·ªëng B·∫Øn laser
    const bulletTimeSystem = {
      isActive: false,
      isReady: true,
      duration: 30000, // 30 gi√¢y
      cooldownTime: 10000, // 10 gi√¢y th·ªùi gian ch·ªù
      currentDuration: 0,
      currentCooldown: 0,
      originalShootCooldown: 10, // L∆∞u l·∫°i th·ªùi gian b·∫Øn g·ªëc
      laserActive: false // Tr·∫°ng th√°i tia laser c√≥ ƒëang ho·∫°t ƒë·ªông kh√¥ng
    };

    function useBulletTime() {
      if (bulletTimeSystem.isReady && !bulletTimeSystem.isActive) {
        bulletTimeSystem.isActive = true;
        bulletTimeSystem.isReady = false;
        bulletTimeSystem.currentDuration = bulletTimeSystem.duration;
        
        // L∆∞u l·∫°i th·ªùi gian b·∫Øn g·ªëc v√† ƒë·∫∑t th√†nh 0 (b·∫Øn li√™n t·ª•c)
        bulletTimeSystem.originalShootCooldown = tank.shootInterval;
        // Kh√¥ng c·∫ßn thay ƒë·ªïi tank.shootCooldown ·ªü ƒë√¢y v√¨ logic b·∫Øn ƒë√£ x·ª≠ l√Ω
        
        // C·∫≠p nh·∫≠t giao di·ªán n√∫t
        updateBulletTimeButton();
        
        // Hi·ªÉn th·ªã th√¥ng b√°o
        showBulletTimeMessage("üî¥ B·∫Øn laser k√≠ch ho·∫°t!");
      }
    }

    function updateBulletTimeButton() {
      if (bulletTimeSystem.isActive) {
        bulletTimeBtn.classList.add('active');
        bulletTimeBtn.classList.remove('disabled');
      } else if (bulletTimeSystem.isReady) {
        bulletTimeBtn.classList.remove('disabled', 'active');
        bulletTimeBtn.style.opacity = '1';
      } else {
        bulletTimeBtn.classList.add('disabled');
        bulletTimeBtn.classList.remove('active');
        bulletTimeBtn.style.opacity = '0.5';
      }
    }

    // H·ªá th·ªëng th√¥ng b√°o b·∫Øn laser
    let bulletTimeMessage = { text: '', time: 0 };
    
    function showBulletTimeMessage(text) {
      bulletTimeMessage.text = text;
      bulletTimeMessage.time = 60; // Hi·ªÉn th·ªã trong 60 frames (1 gi√¢y)
    }

    // H·ªá th·ªëng th√¥ng b√°o chung
    let generalMessage = { text: '', time: 0 };
    
    function showMessage(text) {
      generalMessage.text = text;
      generalMessage.time = 120; // Hi·ªÉn th·ªã trong 120 frames (2 gi√¢y)
    }

    function initWorldSystem() {
      // ƒê·∫∑t offset ban ƒë·∫ßu ƒë·ªÉ xe tƒÉng ·ªü gi·ªØa m√†n h√¨nh
      worldSystem.offsetX = tank.worldX - (canvas.width / 2 - 30);
      worldSystem.offsetY = tank.worldY - (canvas.height / 2 - 25);
      
      // C·∫≠p nh·∫≠t v·ªã tr√≠ xe tƒÉng tr√™n m√†n h√¨nh
      tank.x = tank.worldX - worldSystem.offsetX;
      tank.y = tank.worldY - worldSystem.offsetY;
    }

    // Joystick v√† n√∫t b·∫Øn
    const joystick = {
      active: false,
      baseX: 0,
      baseY: 0,
      handleX: 0,
      handleY: 0,
      limitRadius: 0,
      dx: 0,
      dy: 0
    };
    
    const shootButton = document.getElementById('shootBtn');
    
    // X·ª≠ l√Ω s·ª± ki·ªán ƒëi·ªÅu khi·ªÉn
    function setupControls() {
      // Kh·ªüi t·∫°o joystick
      const baseRect = joystickBase.getBoundingClientRect();
      joystick.baseX = baseRect.left + baseRect.width / 2;
      joystick.baseY = baseRect.top + baseRect.height / 2;
      joystick.limitRadius = baseRect.width / 2 - joystickHandle.offsetWidth / 2;
      
      // ƒê·∫∑t handle v√†o gi·ªØa
      joystick.handleX = joystick.baseX;
      joystick.handleY = joystick.baseY;
      updateJoystickPosition();
      
      // Mouse events for joystick
      joystickHandle.addEventListener('mousedown', startJoystick);
      document.addEventListener('mousemove', moveJoystick);
      document.addEventListener('mouseup', endJoystick);
      
      // Touch events for joystick
      joystickHandle.addEventListener('touchstart', startJoystick);
      document.addEventListener('touchmove', moveJoystick);
      document.addEventListener('touchend', endJoystick);
      document.addEventListener('touchcancel', endJoystick);
      
      // N√∫t b·∫Øn
      shootButton.addEventListener('mousedown', () => keys[' '] = true);
      shootButton.addEventListener('mouseup', () => keys[' '] = false);
      shootButton.addEventListener('mouseleave', () => keys[' '] = false);
      
      // Touch events cho n√∫t b·∫Øn - h·ªó tr·ª£ gi·ªØ ƒë·ªÉ b·∫Øn li√™n t·ª•c
      shootButton.addEventListener('touchstart', (e) => { 
        e.preventDefault(); 
        keys[' '] = true; 
      });
      shootButton.addEventListener('touchend', (e) => { 
        e.preventDefault(); 
        keys[' '] = false; 
      });
      shootButton.addEventListener('touchcancel', (e) => { 
        e.preventDefault(); 
        keys[' '] = false; 
      });
      
      // N√∫t b√¨nh nhi√™n li·ªáu
      fuelBtn.addEventListener('click', useFuel);
      fuelBtn.addEventListener('touchstart', (e) => { e.preventDefault(); useFuel(); });
      
      // N√∫t s√≥ng ƒëi·ªán
      electricWaveBtn.addEventListener('click', useElectricWave);
      electricWaveBtn.addEventListener('touchstart', (e) => { e.preventDefault(); useElectricWave(); });
      
      // N√∫t t√™n l·ª≠a
      missileBtn.addEventListener('click', useMissile);
      missileBtn.addEventListener('touchstart', (e) => { e.preventDefault(); useMissile(); });
      
      // N√∫t B·∫Øn laser
      bulletTimeBtn.addEventListener('click', useBulletTime);
      bulletTimeBtn.addEventListener('touchstart', (e) => { e.preventDefault(); useBulletTime(); });
    }
    
    function startJoystick(e) {
      e.preventDefault();
      joystick.active = true;
      
      // Recalculate base position in case of screen resize
      const baseRect = joystickBase.getBoundingClientRect();
      joystick.baseX = baseRect.left + baseRect.width / 2;
      joystick.baseY = baseRect.top + baseRect.height / 2;
      joystick.limitRadius = baseRect.width / 2 - joystickHandle.offsetWidth / 2;
    }
    
    function moveJoystick(e) {
      if (!joystick.active) return;
      e.preventDefault();
      
      let clientX, clientY;
      
      if (e.type === 'touchmove') {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
      } else {
        clientX = e.clientX;
        clientY = e.clientY;
      }
      
      // Calculate distance from center
      let dx = clientX - joystick.baseX;
      let dy = clientY - joystick.baseY;
      let distance = Math.sqrt(dx * dx + dy * dy);
      
      // Limit to circle
      if (distance > joystick.limitRadius) {
        dx = dx * joystick.limitRadius / distance;
        dy = dy * joystick.limitRadius / distance;
      }
      
      // Update handle position
      joystick.handleX = joystick.baseX + dx;
      joystick.handleY = joystick.baseY + dy;
      
      // Update joystick values for game controls
      joystick.dx = dx / joystick.limitRadius; // -1 to 1
      joystick.dy = dy / joystick.limitRadius; // -1 to 1
      
      // Update visual position
      updateJoystickPosition();
      
      // Update key states based on joystick position
      updateKeyStates();
    }
    
    function endJoystick(e) {
      if (!joystick.active) return;
      e.preventDefault();
      joystick.active = false;
      
      // Reset joystick to center
      joystick.handleX = joystick.baseX;
      joystick.handleY = joystick.baseY;
      joystick.dx = 0;
      joystick.dy = 0;
      
      // Update visual position
      updateJoystickPosition();
      
      // Reset all direction keys
      keys['ArrowUp'] = false;
      keys['ArrowDown'] = false;
      keys['ArrowLeft'] = false;
      keys['ArrowRight'] = false;
    }
    
    function updateJoystickPosition() {
      joystickHandle.style.transform = `translate(${joystick.handleX - joystick.baseX}px, ${joystick.handleY - joystick.baseY}px)`;
    }
    
    function updateKeyStates() {
      // Convert joystick position to key presses
      const deadzone = 0.3; // Ignore small movements
      
      keys['ArrowUp'] = joystick.dy < -deadzone;
      keys['ArrowDown'] = joystick.dy > deadzone;
      keys['ArrowLeft'] = joystick.dx < -deadzone;
      keys['ArrowRight'] = joystick.dx > deadzone;
    }

    function gameLoop() {
      if (gameStarted) {
        update();
        requestAnimationFrame(gameLoop);
      }
    }

startBtn.addEventListener('click', function() {
      startBtn.style.display = 'none';
      canvas.style.display = 'block';
      joystickContainer.style.display = 'block';
      shootControls.style.display = 'block';
      gameStarted = true;
      
      // ƒê·∫£m b·∫£o canvas fullscreen
      resizeCanvas();
      
      // Kh·ªüi t·∫°o h·ªá th·ªëng th·∫ø gi·ªõi
      initWorldSystem();
      
      // Thi·∫øt l·∫≠p ƒëi·ªÅu khi·ªÉn joystick
      setupControls();
      
      // Kh·ªüi t·∫°o tr·∫°ng th√°i n√∫t b√¨nh nhi√™n li·ªáu
      updateFuelButton();
      
      // Kh·ªüi t·∫°o tr·∫°ng th√°i n√∫t s√≥ng ƒëi·ªán
      updateElectricWaveButton();
      
      // Kh·ªüi t·∫°o tr·∫°ng th√°i n√∫t t√™n l·ª≠a
      updateMissileButton();
      
      // Kh·ªüi t·∫°o tr·∫°ng th√°i n√∫t B·∫Øn laser
      updateBulletTimeButton();
      
      bgm.currentTime = 0;
      // Try to play audio, fallback if blocked
      bgm.play().then(() => {
        // success
      }).catch(() => {
        // If failed, show a message and try again on next user gesture
        alert('Click anywhere to enable game music!');
        document.body.addEventListener('click', function tryPlay() {
          bgm.play();
          document.body.removeEventListener('click', tryPlay);
        });
      });
      gameLoop();
    });
  </script>
</body>
</html>
