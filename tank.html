<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>B·∫Øn Xe TƒÉng</title>
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#2196f3">
  <link rel="icon" type="image/png" href="icon-192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="icon-192.png">
  <link rel="icon" type="image/png" sizes="192x192" href="icon-192.png">
  <link rel="apple-touch-icon" href="icon-192.png">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <style>
    * {
      box-sizing: border-box;
    }
    
    body {
      background: #222;
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
      overflow: hidden;
      width: 100vw;
      height: 100vh;
    }
    
    .game-container {
      position: relative;
      width: 100vw;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    
    canvas {
      background: #444;
      width: 100vw;
      height: 100vh;
      display: block;
    }
    
    /* Joystick - g√≥c tr√°i */
    .joystick-container {
      position: fixed;
      bottom: 30px;
      left: 30px;
      display: none;
      z-index: 10;
      width: 150px;
      height: 150px;
      touch-action: none;
    }
    
    .joystick-base {
      position: absolute;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.2);
      border: 2px solid #fff;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(5px);
    }
    
    .joystick-handle {
      position: absolute;
      width: 60px;
      height: 60px;
      background: rgba(255, 255, 255, 0.5);
      border: 2px solid #fff;
      border-radius: 50%;
      cursor: pointer;
      user-select: none;
      transition: transform 0.1s;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-weight: bold;
    }
    
    /* N√∫t b·∫Øn v√† b√¨nh nhi√™n li·ªáu - g√≥c ph·∫£i */
    .shoot-controls {
      position: fixed;
      bottom: 30px;
      right: 30px;
      display: none;
      z-index: 10;
      flex-direction: row;
      gap: 20px;
      align-items: center;
    }
    
    .shoot-btn {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: rgba(255, 235, 59, 0.3);
      border: 3px solid #ffeb3b;
      color: #ffeb3b;
      font-size: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      user-select: none;
      transition: all 0.1s;
      touch-action: manipulation;
      backdrop-filter: blur(5px);
    }
    
    .shoot-btn:hover {
      background: rgba(255, 235, 59, 0.5);
      transform: scale(1.1);
    }
    
    .shoot-btn:active {
      background: rgba(255, 235, 59, 0.7);
      transform: scale(0.9);
    }
    
    /* N√∫t b√¨nh nhi√™n li·ªáu */
    .fuel-btn {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: rgba(76, 175, 80, 0.3);
      border: 3px solid #4caf50;
      color: #4caf50;
      font-size: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      user-select: none;
      transition: all 0.1s;
      touch-action: manipulation;
      backdrop-filter: blur(5px);
      margin-bottom: 10px;
    }
    
    .fuel-btn:hover {
      background: rgba(76, 175, 80, 0.5);
      transform: scale(1.1);
    }
    
    .fuel-btn:active {
      background: rgba(76, 175, 80, 0.7);
      transform: scale(0.9);
    }
    
    .fuel-btn.disabled {
      background: rgba(128, 128, 128, 0.3);
      border-color: #808080;
      color: #808080;
      cursor: not-allowed;
      opacity: 0.5;
    }
    
    .fuel-btn.disabled:hover {
      transform: none;
      background: rgba(128, 128, 128, 0.3);
    }
    
    /* N√∫t tuy·ªát chi√™u s√≥ng ƒëi·ªán */
    .electric-wave-btn {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: rgba(138, 43, 226, 0.3);
      border: 3px solid #8a2be2;
      color: #8a2be2;
      font-size: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      user-select: none;
      transition: all 0.1s;
      touch-action: manipulation;
      backdrop-filter: blur(5px);
      margin-bottom: 10px;
      position: relative;
      overflow: hidden;
    }

    /* N√∫t tuy·ªát chi√™u t√™n l·ª≠a */
    .missile-btn {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: rgba(255, 87, 34, 0.3);
      border: 3px solid #ff5722;
      color: #ff5722;
      font-size: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      user-select: none;
      transition: all 0.1s;
      touch-action: manipulation;
      backdrop-filter: blur(5px);
      margin-bottom: 10px;
      position: relative;
      overflow: hidden;
    }
    
    .missile-btn:hover {
      background: rgba(255, 87, 34, 0.5);
      transform: scale(1.1);
      box-shadow: 0 0 20px rgba(255, 87, 34, 0.6);
    }
    
    .missile-btn:active {
      background: rgba(255, 87, 34, 0.7);
      transform: scale(0.9);
    }
    
    .missile-btn.disabled {
      background: rgba(128, 128, 128, 0.3);
      border-color: #808080;
      color: #808080;
      cursor: not-allowed;
      opacity: 0.5;
    }
    
    .missile-btn.disabled:hover {
      transform: none;
      background: rgba(128, 128, 128, 0.3);
      box-shadow: none;
    }
    
    .electric-wave-btn:hover {
      background: rgba(138, 43, 226, 0.5);
      transform: scale(1.1);
      box-shadow: 0 0 20px rgba(138, 43, 226, 0.6);
    }
    
    .electric-wave-btn:active {
      background: rgba(138, 43, 226, 0.7);
      transform: scale(0.9);
    }
    
    .electric-wave-btn.disabled {
      background: rgba(128, 128, 128, 0.3);
      border-color: #808080;
      color: #808080;
      cursor: not-allowed;
      opacity: 0.5;
    }
    
    .electric-wave-btn.disabled:hover {
      transform: none;
      background: rgba(128, 128, 128, 0.3);
      box-shadow: none;
    }
    
    /* Hi·ªáu ·ª©ng cooldown cho n√∫t t√™n l·ª≠a */
    .missile-btn::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: conic-gradient(transparent 0deg, rgba(255, 87, 34, 0.8) 360deg);
      border-radius: 50%;
      opacity: 0;
      transition: opacity 0.3s;
    }
    
    .missile-btn.cooldown::after {
      opacity: 1;
      animation: cooldownSpin 0.1s linear;
    }

    /* Hi·ªáu ·ª©ng cooldown cho n√∫t s√≥ng ƒëi·ªán */
    .electric-wave-btn::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: conic-gradient(transparent 0deg, rgba(138, 43, 226, 0.8) 360deg);
      border-radius: 50%;
      opacity: 0;
      transition: opacity 0.3s;
    }
    
    .electric-wave-btn.cooldown::after {
      opacity: 1;
      animation: cooldownSpin 0.1s linear;
    }
    
    @keyframes cooldownSpin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    
    /* Responsive cho m√†n h√¨nh nh·ªè */
    @media (max-width: 768px) {
      .joystick-container {
        width: 130px;
        height: 130px;
        bottom: 20px;
        left: 20px;
      }
      
      .joystick-handle {
        width: 50px;
        height: 50px;
      }
      
      .shoot-controls {
        bottom: 20px;
        right: 20px;
        gap: 15px;
      }
      
      .shoot-btn {
        width: 70px;
        height: 70px;
        font-size: 28px;
      }
      
      .fuel-btn {
        width: 70px;
        height: 70px;
        font-size: 28px;
      }
      
      .electric-wave-btn {
        width: 70px;
        height: 70px;
        font-size: 28px;
      }
      
      .missile-btn {
        width: 70px;
        height: 70px;
        font-size: 28px;
      }
    }
    
    @media (max-width: 480px) {
      .joystick-container {
        width: 120px;
        height: 120px;
        bottom: 15px;
        left: 15px;
      }
      
      .joystick-handle {
        width: 45px;
        height: 45px;
      }
      
      .shoot-controls {
        bottom: 15px;
        right: 15px;
        gap: 12px;
      }
      
      .shoot-btn {
        width: 65px;
        height: 65px;
        font-size: 24px;
      }
      
      .fuel-btn {
        width: 65px;
        height: 65px;
        font-size: 24px;
      }
      
      .electric-wave-btn {
        width: 65px;
        height: 65px;
        font-size: 24px;
      }
      
      .missile-btn {
        width: 65px;
        height: 65px;
        font-size: 24px;
      }
    }
    
    @media (max-width: 360px) {
      .joystick-container {
        width: 100px;
        height: 100px;
        bottom: 10px;
        left: 10px;
      }
      
      .joystick-handle {
        width: 40px;
        height: 40px;
      }
      
      .shoot-controls {
        bottom: 10px;
        right: 10px;
        gap: 10px;
      }
      
      .shoot-btn {
        width: 55px;
        height: 55px;
        font-size: 20px;
      }
      
      .fuel-btn {
        width: 55px;
        height: 55px;
        font-size: 20px;
      }
      
      .electric-wave-btn {
        width: 55px;
        height: 55px;
        font-size: 20px;
      }
      
      .missile-btn {
        width: 55px;
        height: 55px;
        font-size: 20px;
      }
    }
  </style>
</head>
<body>
  <div class="game-container">
    <button id="startBtn" style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:2em;padding:0.8em 2em;z-index:20;border:none;background:#4caf50;color:#fff;border-radius:15px;cursor:pointer;box-shadow:0 4px 15px rgba(0,0,0,0.3);">üéÆ B·∫Øt ƒë·∫ßu</button>
    <canvas id="gameCanvas" style="display:none;"></canvas>
    
    <!-- Joystick - g√≥c tr√°i -->
    <div class="joystick-container" id="joystickContainer">
      <div class="joystick-base" id="joystickBase">
        <div class="joystick-handle" id="joystickHandle"></div>
      </div>
    </div>
    
    <!-- N√∫t b·∫Øn v√† b√¨nh nhi√™n li·ªáu - g√≥c ph·∫£i -->
    <div class="shoot-controls" id="shootControls">
      <button class="missile-btn" id="missileBtn">
        <svg width="32" height="32" viewBox="0 0 32 32" fill="currentColor">
          <path d="M16 2 L20 8 L16 12 L12 8 Z"/>
          <rect x="14" y="8" width="4" height="16" rx="2"/>
          <path d="M12 20 L16 24 L20 20"/>
          <circle cx="16" cy="16" r="2" fill="#ffeb3b"/>
          <path d="M8 12 L12 14 L8 16 Z" fill="#ff9800"/>
          <path d="M24 12 L20 14 L24 16 Z" fill="#ff9800"/>
        </svg>
      </button>
      <button class="electric-wave-btn" id="electricWaveBtn">‚ö°</button>
      <button class="fuel-btn" id="fuelBtn">‚õΩ</button>
      <button class="shoot-btn" id="shootBtn"><img src="bullet.png" alt="Bullet" style="width: 30px; height: 30px;"></button>
    </div>
  </div>
  
  <audio id="bgm" src="my-love-don-t-let-love-fade.mp3" loop></audio>
  <script>

    // ƒêƒÉng k√Ω service worker cho PWA
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', function() {
        navigator.serviceWorker.register('sw.js').then(function(reg) {
          // Service worker registered
        }, function(err) {
          // Registration failed
        });
      });
    }

    const startBtn = document.getElementById('startBtn');
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const bgm = document.getElementById('bgm');
    const joystickContainer = document.getElementById('joystickContainer');
    const joystickBase = document.getElementById('joystickBase');
    const joystickHandle = document.getElementById('joystickHandle');
    const shootControls = document.getElementById('shootControls');
    const fuelBtn = document.getElementById('fuelBtn');
    const electricWaveBtn = document.getElementById('electricWaveBtn');
    const missileBtn = document.getElementById('missileBtn');
    
    // Thi·∫øt l·∫≠p canvas fullscreen
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    
    // G·ªçi resize khi t·∫£i trang v√† khi thay ƒë·ªïi k√≠ch th∆∞·ªõc
    window.addEventListener('resize', function() {
      if (gameStarted) {
        resizeCanvas();
      }
    });
    resizeCanvas();

    let gameStarted = false;
    
    // H·ªá th·ªëng chi·∫øn th·∫Øng
    const victorySystem = {
      enemiesKilled: 0,
      targetKills: 1000,
      gameWon: false
    };

    // H·ªá th·ªëng tuy·ªát chi√™u s√≥ng ƒëi·ªán
    const electricWaveSystem = {
      isReady: true,
      cooldownTime: 5000, // 5 gi√¢y cooldown
      currentCooldown: 0,
      waves: [], // M·∫£ng ch·ª©a c√°c s√≥ng ƒëi·ªán ƒëang ho·∫°t ƒë·ªông
      waveRadius: 300, // B√°n k√≠nh t·ªëi ƒëa c·ªßa s√≥ng
      waveDamage: 5, // S√°t th∆∞∆°ng c·ªßa s√≥ng ƒëi·ªán
      waveSpeed: 8 // T·ªëc ƒë·ªô lan truy·ªÅn s√≥ng
    };

    // H·ªá th·ªëng tuy·ªát chi√™u t√™n l·ª≠a
    const missileSystem = {
      isReady: true,
      cooldownTime: 3000, // 3 gi√¢y cooldown
      currentCooldown: 0,
      missiles: [], // M·∫£ng ch·ª©a c√°c t√™n l·ª≠a ƒëang bay
      missileSpeed: 6, // T·ªëc ƒë·ªô t√™n l·ª≠a
      missileDamage: 10, // S√°t th∆∞∆°ng c·ªßa t√™n l·ª≠a
      explosionRadius: 80, // B√°n k√≠nh n·ªï
      homingRange: 200 // Ph·∫°m vi t·ª± ƒë·ªông t√¨m m·ª•c ti√™u
    };

    // H·ªá th·ªëng b·∫£n ƒë·ªì v√¥ t·∫≠n
    const worldSystem = {
      offsetX: 0,
      offsetY: 0,
      tileSize: 40,
      terrain: [],
      decorations: []
    };

    // Sinh ƒë·ªãa h√¨nh v√† trang tr√≠
    function generateTerrain(startX, startY, width, height) {
      for (let x = startX; x < startX + width; x++) {
        for (let y = startY; y < startY + height; y++) {
          let key = `${x},${y}`;
          if (!worldSystem.terrain[key]) {
            // Sinh ƒë·ªãa h√¨nh c∆° b·∫£n
            let terrainType = 'grass';
            if (Math.random() < 0.1) terrainType = 'dirt';
            else if (Math.random() < 0.05) terrainType = 'stone';
            
            worldSystem.terrain[key] = {
              type: terrainType,
              x: x,
              y: y
            };
            
            // Sinh trang tr√≠
            if (Math.random() < 0.08) {
              let decorationType = 'grass_tuft';
              if (Math.random() < 0.3) decorationType = 'small_rock';
              else if (Math.random() < 0.1) decorationType = 'tree';
              else if (Math.random() < 0.2) decorationType = 'bush';
              
              worldSystem.decorations.push({
                type: decorationType,
                x: x * worldSystem.tileSize + Math.random() * worldSystem.tileSize,
                y: y * worldSystem.tileSize + Math.random() * worldSystem.tileSize,
                size: 0.5 + Math.random() * 0.5
              });
            }
          }
        }
      }
    }

    // V·∫Ω ƒë·ªãa h√¨nh
    function drawTerrain() {
      const startTileX = Math.floor(worldSystem.offsetX / worldSystem.tileSize) - 1;
      const startTileY = Math.floor(worldSystem.offsetY / worldSystem.tileSize) - 1;
      const endTileX = startTileX + Math.ceil(canvas.width / worldSystem.tileSize) + 2;
      const endTileY = startTileY + Math.ceil(canvas.height / worldSystem.tileSize) + 2;
      
      // Sinh th√™m ƒë·ªãa h√¨nh n·∫øu c·∫ßn
      generateTerrain(startTileX, startTileY, endTileX - startTileX, endTileY - startTileY);
      
      // V·∫Ω ƒë·ªãa h√¨nh
      for (let x = startTileX; x < endTileX; x++) {
        for (let y = startTileY; y < endTileY; y++) {
          let key = `${x},${y}`;
          let terrain = worldSystem.terrain[key];
          if (terrain) {
            let screenX = x * worldSystem.tileSize - worldSystem.offsetX;
            let screenY = y * worldSystem.tileSize - worldSystem.offsetY;
            
            switch (terrain.type) {
              case 'grass':
                ctx.fillStyle = '#4a7c59';
                break;
              case 'dirt':
                ctx.fillStyle = '#8b4513';
                break;
              case 'stone':
                ctx.fillStyle = '#696969';
                break;
            }
            ctx.fillRect(screenX, screenY, worldSystem.tileSize, worldSystem.tileSize);
          }
        }
      }
    }

    // V·∫Ω trang tr√≠
    function drawDecorations() {
      for (let decoration of worldSystem.decorations) {
        let screenX = decoration.x - worldSystem.offsetX;
        let screenY = decoration.y - worldSystem.offsetY;
        
        // Ch·ªâ v·∫Ω n·∫øu trong ph·∫°m vi m√†n h√¨nh
        if (screenX > -50 && screenX < canvas.width + 50 && 
            screenY > -50 && screenY < canvas.height + 50) {
          
          ctx.save();
          let size = decoration.size * 20;
          
          switch (decoration.type) {
            case 'grass_tuft':
              ctx.fillStyle = '#228B22';
              ctx.beginPath();
              for (let i = 0; i < 5; i++) {
                let angle = (i / 5) * Math.PI * 2;
                let x = screenX + Math.cos(angle) * size * 0.3;
                let y = screenY + Math.sin(angle) * size * 0.2;
                ctx.lineTo(x, y);
              }
              ctx.fill();
              break;
              
            case 'small_rock':
              ctx.fillStyle = '#A0A0A0';
              ctx.beginPath();
              ctx.arc(screenX, screenY, size * 0.4, 0, Math.PI * 2);
              ctx.fill();
              ctx.fillStyle = '#808080';
              ctx.beginPath();
              ctx.arc(screenX - size * 0.1, screenY - size * 0.1, size * 0.2, 0, Math.PI * 2);
              ctx.fill();
              break;
              
            case 'tree':
              // Th√¢n c√¢y
              ctx.fillStyle = '#8B4513';
              ctx.fillRect(screenX - size * 0.1, screenY - size * 0.3, size * 0.2, size * 0.6);
              // L√° c√¢y
              ctx.fillStyle = '#228B22';
              ctx.beginPath();
              ctx.arc(screenX, screenY - size * 0.3, size * 0.4, 0, Math.PI * 2);
              ctx.fill();
              break;
              
            case 'bush':
              ctx.fillStyle = '#32CD32';
              ctx.beginPath();
              ctx.arc(screenX, screenY, size * 0.3, 0, Math.PI * 2);
              ctx.fill();
              ctx.fillStyle = '#228B22';
              ctx.beginPath();
              ctx.arc(screenX - size * 0.1, screenY - size * 0.1, size * 0.2, 0, Math.PI * 2);
              ctx.fill();
              break;
          }
          ctx.restore();
        }
      }
    }

    const tank = {
        x: 400, // V·ªã tr√≠ tr√™n m√†n h√¨nh
        y: 300, // V·ªã tr√≠ tr√™n m√†n h√¨nh
        speed: 3,
        hp: 1000000000000000000000000000000000000,
        maxHp: 1000000000000000000000000000000000,
        worldX: 400, // V·ªã tr√≠ th·ª±c trong th·∫ø gi·ªõi
        worldY: 300
    };


    let bullets = [];
    const bulletSpeed = 10;

    // ƒê·∫°n c·ªßa xe tƒÉng ƒë·ªãch
    let enemyBullets = [];
    const enemyBulletSpeed = 5;


    function drawBullet(bullet, color = '#ffeb3b') {
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(bullet.x, bullet.y, 5, 0, Math.PI * 2);
      ctx.fill();
    }

    function drawExplosion(x, y) {
      ctx.save();
      ctx.beginPath();
      ctx.arc(x + 30, y + 35, 25, 0, Math.PI * 2);
      ctx.fillStyle = 'orange';
      ctx.globalAlpha = 0.7;
      ctx.fill();
      ctx.beginPath();
      ctx.arc(x + 30, y + 35, 12, 0, Math.PI * 2);
      ctx.fillStyle = 'yellow';
      ctx.globalAlpha = 0.9;
      ctx.fill();
      ctx.globalAlpha = 1;
      ctx.restore();
    }

    // H√†m s·ª≠ d·ª•ng tuy·ªát chi√™u s√≥ng ƒëi·ªán
    function useElectricWave() {
      if (!electricWaveSystem.isReady) return;
      
      // T·∫°o s√≥ng ƒëi·ªán m·ªõi
      electricWaveSystem.waves.push({
        x: tank.x + 30, // T√¢m xe tƒÉng
        y: tank.y + 35,
        worldX: tank.worldX + 30,
        worldY: tank.worldY + 35,
        radius: 0,
        maxRadius: electricWaveSystem.waveRadius,
        speed: electricWaveSystem.waveSpeed,
        damage: electricWaveSystem.waveDamage,
        opacity: 1,
        hitEnemies: [] // Danh s√°ch k·∫ª ƒë·ªãch ƒë√£ b·ªã tr√∫ng ƒë·ªÉ tr√°nh hit nhi·ªÅu l·∫ßn
      });
      
      // B·∫Øt ƒë·∫ßu cooldown
      electricWaveSystem.isReady = false;
      electricWaveSystem.currentCooldown = electricWaveSystem.cooldownTime;
      updateElectricWaveButton();
    }

    // H√†m v·∫Ω s√≥ng ƒëi·ªán
    function drawElectricWave(wave) {
      ctx.save();
      
      // V·∫Ω v√≤ng tr√≤n s√≥ng ƒëi·ªán ch√≠nh
      ctx.beginPath();
      ctx.arc(wave.x, wave.y, wave.radius, 0, Math.PI * 2);
      ctx.strokeStyle = `rgba(138, 43, 226, ${wave.opacity})`;
      ctx.lineWidth = 4;
      ctx.stroke();
      
      // V·∫Ω hi·ªáu ·ª©ng tia ch·ªõp
      ctx.strokeStyle = `rgba(255, 255, 255, ${wave.opacity * 0.8})`;
      ctx.lineWidth = 2;
      for (let i = 0; i < 8; i++) {
        let angle = (i / 8) * Math.PI * 2;
        let innerRadius = wave.radius * 0.7;
        let outerRadius = wave.radius * 1.1;
        
        ctx.beginPath();
        ctx.moveTo(
          wave.x + Math.cos(angle) * innerRadius,
          wave.y + Math.sin(angle) * innerRadius
        );
        ctx.lineTo(
          wave.x + Math.cos(angle) * outerRadius,
          wave.y + Math.sin(angle) * outerRadius
        );
        ctx.stroke();
      }
      
      // V·∫Ω v√≤ng tr√≤n b√™n trong v·ªõi hi·ªáu ·ª©ng ph√°t s√°ng
      if (wave.radius > 20) {
        ctx.beginPath();
        ctx.arc(wave.x, wave.y, wave.radius * 0.3, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(138, 43, 226, ${wave.opacity * 0.3})`;
        ctx.fill();
      }
      
      ctx.restore();
    }

    // H√†m c·∫≠p nh·∫≠t n√∫t s√≥ng ƒëi·ªán
    function updateElectricWaveButton() {
      if (electricWaveSystem.isReady) {
        electricWaveBtn.classList.remove('disabled');
        electricWaveBtn.classList.remove('cooldown');
        electricWaveBtn.style.opacity = '1';
      } else {
        electricWaveBtn.classList.add('disabled');
        electricWaveBtn.classList.add('cooldown');
        electricWaveBtn.style.opacity = '0.5';
      }
    }

    // H√†m s·ª≠ d·ª•ng tuy·ªát chi√™u t√™n l·ª≠a
    function useMissile() {
      if (!missileSystem.isReady) return;
      
      // T·∫°o t√™n l·ª≠a m·ªõi
      missileSystem.missiles.push({
        x: tank.x + 30, // T√¢m xe tƒÉng
        y: tank.y + 35,
        worldX: tank.worldX + 30,
        worldY: tank.worldY + 35,
        vx: 0, // V·∫≠n t·ªëc ban ƒë·∫ßu
        vy: -missileSystem.missileSpeed,
        target: null, // M·ª•c ti√™u hi·ªán t·∫°i
        hasExploded: false,
        trailPoints: [] // ƒêi·ªÉm ƒë·ªÉ v·∫Ω ƒëu√¥i kh√≥i
      });
      
      // B·∫Øt ƒë·∫ßu cooldown
      missileSystem.isReady = false;
      missileSystem.currentCooldown = missileSystem.cooldownTime;
      updateMissileButton();
    }

    // H√†m v·∫Ω t√™n l·ª≠a
    function drawMissile(missile) {
      ctx.save();
      
      // V·∫Ω ƒëu√¥i kh√≥i
      if (missile.trailPoints.length > 1) {
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(missile.trailPoints[0].x, missile.trailPoints[0].y);
        for (let i = 1; i < missile.trailPoints.length; i++) {
          let alpha = i / missile.trailPoints.length * 0.6;
          ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
          ctx.lineTo(missile.trailPoints[i].x, missile.trailPoints[i].y);
        }
        ctx.stroke();
      }
      
      // T√≠nh g√≥c quay c·ªßa t√™n l·ª≠a
      let angle = Math.atan2(missile.vy, missile.vx) + Math.PI / 2;
      
      ctx.translate(missile.x, missile.y);
      ctx.rotate(angle);
      
      // V·∫Ω th√¢n t√™n l·ª≠a
      ctx.fillStyle = '#ff5722';
      ctx.fillRect(-4, -12, 8, 24);
      
      // V·∫Ω ƒë·∫ßu t√™n l·ª≠a
      ctx.fillStyle = '#d32f2f';
      ctx.beginPath();
      ctx.moveTo(0, -12);
      ctx.lineTo(-4, -8);
      ctx.lineTo(4, -8);
      ctx.closePath();
      ctx.fill();
      
      // V·∫Ω c√°nh t√™n l·ª≠a
      ctx.fillStyle = '#ff9800';
      ctx.beginPath();
      ctx.moveTo(-6, 8);
      ctx.lineTo(-2, 4);
      ctx.lineTo(-2, 12);
      ctx.closePath();
      ctx.fill();
      
      ctx.beginPath();
      ctx.moveTo(6, 8);
      ctx.lineTo(2, 4);
      ctx.lineTo(2, 12);
      ctx.closePath();
      ctx.fill();
      
      // V·∫Ω l·ª≠a ph√≠a sau
      ctx.fillStyle = '#ffeb3b';
      ctx.beginPath();
      ctx.moveTo(-2, 12);
      ctx.lineTo(0, 18);
      ctx.lineTo(2, 12);
      ctx.closePath();
      ctx.fill();
      
      ctx.restore();
    }

    // H√†m v·∫Ω v·ª• n·ªï t√™n l·ª≠a
    function drawMissileExplosion(x, y, radius, opacity) {
      ctx.save();
      
      // V√≤ng n·ªï ch√≠nh
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(255, 87, 34, ${opacity})`;
      ctx.fill();
      
      // V√≤ng n·ªï b√™n trong
      ctx.beginPath();
      ctx.arc(x, y, radius * 0.7, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(255, 193, 7, ${opacity})`;
      ctx.fill();
      
      // V√≤ng n·ªï trung t√¢m
      ctx.beginPath();
      ctx.arc(x, y, radius * 0.4, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
      ctx.fill();
      
      ctx.restore();
    }

    // H√†m c·∫≠p nh·∫≠t n√∫t t√™n l·ª≠a
    function updateMissileButton() {
      if (missileSystem.isReady) {
        missileBtn.classList.remove('disabled');
        missileBtn.classList.remove('cooldown');
        missileBtn.style.opacity = '1';
      } else {
        missileBtn.classList.add('disabled');
        missileBtn.classList.add('cooldown');
        missileBtn.style.opacity = '0.5';
      }
    }

function drawTank(x, y, color = '#4caf50', turretColor = '#388e3c', reverse = false, hp, maxHp) {
  // reverse = false: xe tƒÉng h∆∞·ªõng l√™n, true: h∆∞·ªõng xu·ªëng
  ctx.save();
  if (reverse) {
    ctx.translate(x + 30, y + 35);
    ctx.rotate(Math.PI);
    ctx.translate(-x - 30, -y - 35);
  }
  // V·∫Ω c·ªôt m√°u n·∫øu c√≥ hp v√† maxHp (∆∞u ti√™n v·∫Ω tr∆∞·ªõc ƒë·ªÉ kh√¥ng b·ªã che)
  if (typeof hp === 'number' && typeof maxHp === 'number') {
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.strokeRect(x + 5, y - 15, 50, 7);
    // Thanh m√°u n·ªÅn
    ctx.fillStyle = '#f44336';
    ctx.fillRect(x + 5, y - 15, 50, 7);
    // ƒê·ªïi m√†u health bar theo ph·∫ßn trƒÉm m√°u
    let percent = Math.max(0, Math.min(1, hp / maxHp));
    if (percent > 0.6) ctx.fillStyle = '#76ff03'; // xanh
    else if (percent > 0.3) ctx.fillStyle = '#ffeb3b'; // v√†ng
    else ctx.fillStyle = '#f44336'; // ƒë·ªè
    ctx.fillRect(x + 5, y - 15, 50 * percent, 7);
  }
  // Th√¢n xe
  ctx.fillStyle = color;
  ctx.fillRect(x, y + 20, 60, 30);
  // Th√°p ph√°o
  ctx.fillStyle = turretColor;
  ctx.fillRect(x + 15, y, 30, 30);
  // N√≤ng ph√°o
  ctx.fillStyle = '#222';
  ctx.fillRect(x + 27, y - 20, 6, 20);
  // B√°nh xe
  ctx.fillStyle = '#222';
  for (let i = 0; i < 3; i++) {
    ctx.beginPath();
    ctx.arc(x + 15 + i * 15, y + 50, 8, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.restore();
}
// Enemy tanks
let enemies = [];
const enemySpeed = 2;
const enemySpawnInterval = 12; // frames - tƒÉng t·ªëc ƒë·ªô spawn 10 l·∫ßn
let frameCount = 0;
let enemyIdCounter = 0; // ƒê·∫øm ID duy nh·∫•t cho m·ªói k·∫ª ƒë·ªãch

function spawnEnemy() {
  // Random x position trong th·∫ø gi·ªõi, spawn ph√≠a tr√™n tank
  const x = Math.floor(Math.random() * (canvas.width - 60));
  const worldX = x + worldSystem.offsetX;
  const worldY = worldSystem.offsetY - 100; // Spawn ph√≠a tr√™n v√πng nh√¨n th·∫•y
  
  // enemy s·∫Ω c√≥ h∆∞·ªõng di chuy·ªÉn ng·∫´u nhi√™n ban ƒë·∫ßu
  const dx = Math.random() < 0.5 ? enemySpeed : -enemySpeed;
  const dy = 1.5; // t·ªëc ƒë·ªô xu·ªëng ·ªïn ƒë·ªãnh
  
  // Th√™m h·ªá th·ªëng m√°u cho xe tƒÉng ƒë·ªãch v√† v·ªã tr√≠ th·∫ø gi·ªõi
  enemies.push({ 
    id: enemyIdCounter++, // ID duy nh·∫•t
    x: x, 
    y: -100, 
    dx: dx, 
    dy: dy, 
    hp: 3, 
    maxHp: 3,
    worldX: worldX,
    worldY: worldY
  });
}

    function clear() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

function update() {
  clear();
  
  // V·∫Ω b·∫£n ƒë·ªì v√¥ t·∫≠n
  drawTerrain();
  drawDecorations();
  
  // Hi·ªáu ·ª©ng n·ªï cho tank ng∆∞·ªùi ch∆°i
  if (typeof window.tankExplosions === 'undefined') window.tankExplosions = [];

  // Ki·ªÉm tra chi·∫øn th·∫Øng
  if (victorySystem.gameWon) {
    showVictoryScreen();
    return;
  }
  
  // N·∫øu ƒë√£ thua th√¨ v·∫Ω n·ªï v√† th√¥ng b√°o, kh√¥ng update n·ªØa
  if (tank.hp <= 0) {
    // V·∫Ω hi·ªáu ·ª©ng n·ªï nhi·ªÅu frame
    if (window.tankExplosions.length === 0) {
      for (let i = 0; i < 20; i++) {
        window.tankExplosions.push({ x: tank.x, y: tank.y, time: i * 2 });
      }
    }
    for (let i = window.tankExplosions.length - 1; i >= 0; i--) {
      let ex = window.tankExplosions[i];
      if (ex.time <= 30) drawExplosion(ex.x, ex.y);
      ex.time++;
      if (ex.time > 30) window.tankExplosions.splice(i, 1);
    }
    ctx.save();
    ctx.font = 'bold 2.2em Arial';
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'center';
    ctx.shadowColor = '#000';
    ctx.shadowBlur = 8;
    ctx.fillText('B·∫°n ƒë√£ thua tr√≤ ch∆°i', canvas.width / 2, canvas.height / 2);
    ctx.restore();
    // Hi·ªán n√∫t ch∆°i l·∫°i
    showReplayButton();
    return;
  }
  
  // Smooth tank movement v·ªõi h·ªá th·ªëng th·∫ø gi·ªõi v√¥ t·∫≠n
  let newWorldX = tank.worldX;
  let newWorldY = tank.worldY;
  
  if (keys['ArrowLeft']) {
    newWorldX -= tank.speed;
  }
  if (keys['ArrowRight']) {
    newWorldX += tank.speed;
  }
  if (keys['ArrowUp']) {
    newWorldY -= tank.speed;
  }
  if (keys['ArrowDown']) {
    newWorldY += tank.speed;
  }
  
  // C·∫≠p nh·∫≠t v·ªã tr√≠ th·∫ø gi·ªõi
  tank.worldX = newWorldX;
  tank.worldY = newWorldY;
  
  // Gi·ªØ xe tƒÉng ·ªü trung t√¢m m√†n h√¨nh khi c√≥ th·ªÉ
  let targetScreenX = canvas.width / 2 - 30;
  let targetScreenY = canvas.height / 2 - 25;
  
  // C·∫≠p nh·∫≠t offset ƒë·ªÉ xe tƒÉng lu√¥n ·ªü gi·ªØa
  worldSystem.offsetX = tank.worldX - targetScreenX;
  worldSystem.offsetY = tank.worldY - targetScreenY;
  
  // C·∫≠p nh·∫≠t v·ªã tr√≠ xe tƒÉng tr√™n m√†n h√¨nh
  tank.x = tank.worldX - worldSystem.offsetX;
  tank.y = tank.worldY - worldSystem.offsetY;

  // B·∫Øn ƒë·∫°n
  if (keys[' ']) {
    bullets.push({ x: tank.x + 30, y: tank.y, worldX: tank.worldX + 30, worldY: tank.worldY });
    keys[' '] = false; // Ch·ªâ b·∫Øn m·ªôt vi√™n m·ªói l·∫ßn nh·∫•n
  }

  // C·∫≠p nh·∫≠t ƒë·∫°n c·ªßa ng∆∞·ªùi ch∆°i
  for (let i = bullets.length - 1; i >= 0; i--) {
    let bullet = bullets[i];
    bullet.worldY -= bulletSpeed;
    bullet.y = bullet.worldY - worldSystem.offsetY;
    
    // X√≥a ƒë·∫°n n·∫øu ra kh·ªèi m√†n h√¨nh
    if (bullet.y < -10) {
      bullets.splice(i, 1);
    }
  }

  // Spawn enemies
  frameCount++;
  if (frameCount % enemySpawnInterval === 0) {
    spawnEnemy();
  }

  // C·∫≠p nh·∫≠t enemies
  for (let i = enemies.length - 1; i >= 0; i--) {
    let enemy = enemies[i];
    
    // C·∫≠p nh·∫≠t v·ªã tr√≠ th·∫ø gi·ªõi
    enemy.worldX += enemy.dx;
    enemy.worldY += enemy.dy;
    
    // C·∫≠p nh·∫≠t v·ªã tr√≠ tr√™n m√†n h√¨nh
    enemy.x = enemy.worldX - worldSystem.offsetX;
    enemy.y = enemy.worldY - worldSystem.offsetY;
    
    // ƒê·ªïi h∆∞·ªõng khi ch·∫°m bi√™n
    if (enemy.x <= 0 || enemy.x >= canvas.width - 60) {
      enemy.dx = -enemy.dx;
    }
    
    // X√≥a enemy n·∫øu ra kh·ªèi m√†n h√¨nh d∆∞·ªõi
    if (enemy.y > canvas.height + 100) {
      enemies.splice(i, 1);
      continue;
    }
    
    // Enemy b·∫Øn ƒë·∫°n ng·∫´u nhi√™n
    if (Math.random() < 0.01) {
      enemyBullets.push({ 
        x: enemy.x + 30, 
        y: enemy.y + 70,
        worldX: enemy.worldX + 30,
        worldY: enemy.worldY + 70
      });
    }
  }

  // C·∫≠p nh·∫≠t ƒë·∫°n c·ªßa enemy
  for (let i = enemyBullets.length - 1; i >= 0; i--) {
    let bullet = enemyBullets[i];
    bullet.worldY += enemyBulletSpeed;
    bullet.y = bullet.worldY - worldSystem.offsetY;
    
    // X√≥a ƒë·∫°n n·∫øu ra kh·ªèi m√†n h√¨nh
    if (bullet.y > canvas.height + 10) {
      enemyBullets.splice(i, 1);
    }
  }

  // Ki·ªÉm tra va ch·∫°m ƒë·∫°n ng∆∞·ªùi ch∆°i v·ªõi enemies
  for (let i = bullets.length - 1; i >= 0; i--) {
    for (let j = enemies.length - 1; j >= 0; j--) {
      let bullet = bullets[i];
      let enemy = enemies[j];
      
      if (bullet && enemy && 
          bullet.x > enemy.x && bullet.x < enemy.x + 60 &&
          bullet.y > enemy.y && bullet.y < enemy.y + 70) {
        
        // Gi·∫£m m√°u enemy
        enemy.hp--;
        
        // Th√™m hi·ªáu ·ª©ng n·ªï
        if (typeof window.explosions === 'undefined') window.explosions = [];
        window.explosions.push({ x: enemy.x, y: enemy.y, time: 0 });
        
        // X√≥a ƒë·∫°n
        bullets.splice(i, 1);
        
        // N·∫øu m√°u v·ªÅ 0 th√¨ th√™m hi·ªáu ·ª©ng n·ªï v√† x√≥a xe tƒÉng
        if (enemy.hp <= 0) {
          window.explosions.push({ x: enemy.x, y: enemy.y, time: 0 });
          enemies.splice(j, 1);
          
          // TƒÉng s·ªë qu√¢n ƒë·ªãch ƒë√£ ti√™u di·ªát
          victorySystem.enemiesKilled++;
          
          // Ki·ªÉm tra ƒëi·ªÅu ki·ªán chi·∫øn th·∫Øng
          if (victorySystem.enemiesKilled >= victorySystem.targetKills) {
            victorySystem.gameWon = true;
          }
        }
        break;
      }
    }
  }

  // Ki·ªÉm tra va ch·∫°m ƒë·∫°n enemy v·ªõi tank ng∆∞·ªùi ch∆°i
  for (let i = enemyBullets.length - 1; i >= 0; i--) {
    let bullet = enemyBullets[i];
    
    if (bullet.x > tank.x && bullet.x < tank.x + 60 &&
        bullet.y > tank.y && bullet.y < tank.y + 70) {
      
      // Gi·∫£m m√°u tank
      tank.hp--;
      
      // Th√™m hi·ªáu ·ª©ng n·ªï khi tank b·ªã tr√∫ng
      if (typeof window.tankHitExplosions === 'undefined') window.tankHitExplosions = [];
      window.tankHitExplosions.push({ x: tank.x, y: tank.y, time: 0 });
      
      // X√≥a ƒë·∫°n
      enemyBullets.splice(i, 1);
    }
  }

  // V·∫Ω hi·ªáu ·ª©ng n·ªï khi tank b·ªã tr√∫ng
  if (typeof window.tankHitExplosions !== 'undefined') {
    for (let i = window.tankHitExplosions.length - 1; i >= 0; i--) {
      let ex = window.tankHitExplosions[i];
      if (ex.time <= 15) drawExplosion(ex.x, ex.y);
      ex.time++;
      if (ex.time > 15) window.tankHitExplosions.splice(i, 1);
    }
  }

  // V·∫Ω tank ng∆∞·ªùi ch∆°i (ch·ªâ khi c√≤n s·ªëng)
  if (tank.hp > 0) {
    drawTank(tank.x, tank.y, '#4caf50', '#388e3c', false, tank.hp, tank.maxHp);
  }

  // V·∫Ω enemies
  for (let enemy of enemies) {
    drawTank(enemy.x, enemy.y, '#f44336', '#d32f2f', true, enemy.hp, enemy.maxHp);
  }

  // V·∫Ω ƒë·∫°n c·ªßa ng∆∞·ªùi ch∆°i
  for (let bullet of bullets) {
    drawBullet(bullet, '#ffeb3b');
  }

  // V·∫Ω ƒë·∫°n c·ªßa enemy
  for (let bullet of enemyBullets) {
    drawBullet(bullet, '#f44336');
  }

  // V·∫Ω hi·ªáu ·ª©ng n·ªï
  if (typeof window.explosions !== 'undefined') {
    for (let i = window.explosions.length - 1; i >= 0; i--) {
      let ex = window.explosions[i];
      if (ex.time <= 30) drawExplosion(ex.x, ex.y);
      ex.time++;
      if (ex.time > 30) window.explosions.splice(i, 1);
    }
  }

  // C·∫≠p nh·∫≠t v√† v·∫Ω s√≥ng ƒëi·ªán
  for (let i = electricWaveSystem.waves.length - 1; i >= 0; i--) {
    let wave = electricWaveSystem.waves[i];
    
    // C·∫≠p nh·∫≠t v·ªã tr√≠ s√≥ng tr√™n m√†n h√¨nh
    wave.x = wave.worldX - worldSystem.offsetX;
    wave.y = wave.worldY - worldSystem.offsetY;
    
    // TƒÉng b√°n k√≠nh s√≥ng
    wave.radius += wave.speed;
    
    // Gi·∫£m ƒë·ªô trong su·ªët theo th·ªùi gian
    wave.opacity = Math.max(0, 1 - (wave.radius / wave.maxRadius));
    
    // Ki·ªÉm tra va ch·∫°m v·ªõi k·∫ª ƒë·ªãch
    for (let j = enemies.length - 1; j >= 0; j--) {
      let enemy = enemies[j];
      
      // Ki·ªÉm tra xem k·∫ª ƒë·ªãch ƒë√£ b·ªã tr√∫ng ch∆∞a
      if (wave.hitEnemies.includes(enemy.id)) continue;
      
      // T√≠nh kho·∫£ng c√°ch t·ª´ t√¢m s√≥ng ƒë·∫øn k·∫ª ƒë·ªãch
      let dx = enemy.x + 30 - wave.x;
      let dy = enemy.y + 35 - wave.y;
      let distance = Math.sqrt(dx * dx + dy * dy);
      
      // N·∫øu k·∫ª ƒë·ªãch n·∫±m trong ph·∫°m vi s√≥ng
      if (distance <= wave.radius && distance >= wave.radius - wave.speed * 2) {
        // G√¢y s√°t th∆∞∆°ng
        enemy.hp -= wave.damage;
        
        // Th√™m hi·ªáu ·ª©ng n·ªï ƒëi·ªán
        if (typeof window.electricExplosions === 'undefined') window.electricExplosions = [];
        window.electricExplosions.push({ x: enemy.x, y: enemy.y, time: 0 });
        
        // ƒê√°nh d·∫•u k·∫ª ƒë·ªãch ƒë√£ b·ªã tr√∫ng
        wave.hitEnemies.push(enemy.id);
        
        // N·∫øu k·∫ª ƒë·ªãch ch·∫øt
        if (enemy.hp <= 0) {
          if (typeof window.explosions === 'undefined') window.explosions = [];
          window.explosions.push({ x: enemy.x, y: enemy.y, time: 0 });
          enemies.splice(j, 1);
          
          // TƒÉng s·ªë qu√¢n ƒë·ªãch ƒë√£ ti√™u di·ªát
          victorySystem.enemiesKilled++;
          
          // Ki·ªÉm tra ƒëi·ªÅu ki·ªán chi·∫øn th·∫Øng
          if (victorySystem.enemiesKilled >= victorySystem.targetKills) {
            victorySystem.gameWon = true;
          }
        }
      }
    }
    
    // V·∫Ω s√≥ng ƒëi·ªán
    if (wave.x > -wave.maxRadius && wave.x < canvas.width + wave.maxRadius && 
        wave.y > -wave.maxRadius && wave.y < canvas.height + wave.maxRadius) {
      drawElectricWave(wave);
    }
    
    // X√≥a s√≥ng khi ƒë√£ h·∫øt hi·ªáu l·ª±c
    if (wave.radius >= wave.maxRadius) {
      electricWaveSystem.waves.splice(i, 1);
    }
  }

  // V·∫Ω hi·ªáu ·ª©ng n·ªï ƒëi·ªán
  if (typeof window.electricExplosions !== 'undefined') {
    for (let i = window.electricExplosions.length - 1; i >= 0; i--) {
      let ex = window.electricExplosions[i];
      if (ex.time <= 20) {
        // V·∫Ω hi·ªáu ·ª©ng n·ªï ƒëi·ªán
        ctx.save();
        ctx.beginPath();
        ctx.arc(ex.x + 30, ex.y + 35, 15 + ex.time, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(138, 43, 226, ${1 - ex.time / 20})`;
        ctx.lineWidth = 3;
        ctx.stroke();
        
        // V·∫Ω tia ch·ªõp nh·ªè
        for (let j = 0; j < 6; j++) {
          let angle = (j / 6) * Math.PI * 2 + ex.time * 0.2;
          let radius = 10 + ex.time * 0.5;
          ctx.beginPath();
          ctx.moveTo(ex.x + 30, ex.y + 35);
          ctx.lineTo(
            ex.x + 30 + Math.cos(angle) * radius,
            ex.y + 35 + Math.sin(angle) * radius
          );
          ctx.strokeStyle = `rgba(255, 255, 255, ${1 - ex.time / 20})`;
          ctx.lineWidth = 2;
          ctx.stroke();
        }
        ctx.restore();
      }
      ex.time++;
      if (ex.time > 20) window.electricExplosions.splice(i, 1);
    }
  }

  // C·∫≠p nh·∫≠t cooldown s√≥ng ƒëi·ªán
  if (!electricWaveSystem.isReady) {
    electricWaveSystem.currentCooldown -= 16.67; // Gi·∫£ s·ª≠ 60 FPS
    if (electricWaveSystem.currentCooldown <= 0) {
      electricWaveSystem.isReady = true;
      updateElectricWaveButton();
    }
  }

  // C·∫≠p nh·∫≠t v√† v·∫Ω t√™n l·ª≠a
  for (let i = missileSystem.missiles.length - 1; i >= 0; i--) {
    let missile = missileSystem.missiles[i];
    
    // C·∫≠p nh·∫≠t v·ªã tr√≠ t√™n l·ª≠a tr√™n m√†n h√¨nh
    missile.x = missile.worldX - worldSystem.offsetX;
    missile.y = missile.worldY - worldSystem.offsetY;
    
    // T√¨m m·ª•c ti√™u g·∫ßn nh·∫•t n·∫øu ch∆∞a c√≥
    if (!missile.target) {
      let closestDistance = missileSystem.homingRange;
      let closestEnemy = null;
      
      for (let enemy of enemies) {
        let dx = enemy.worldX + 30 - missile.worldX;
        let dy = enemy.worldY + 35 - missile.worldY;
        let distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < closestDistance) {
          closestDistance = distance;
          closestEnemy = enemy;
        }
      }
      
      missile.target = closestEnemy;
    }
    
    // C·∫≠p nh·∫≠t h∆∞·ªõng bay c·ªßa t√™n l·ª≠a
    if (missile.target) {
      let dx = missile.target.worldX + 30 - missile.worldX;
      let dy = missile.target.worldY + 35 - missile.worldY;
      let distance = Math.sqrt(dx * dx + dy * dy);
      
      if (distance > 0) {
        // T√≠nh h∆∞·ªõng m·ªõi
        let targetVx = (dx / distance) * missileSystem.missileSpeed;
        let targetVy = (dy / distance) * missileSystem.missileSpeed;
        
        // L√†m m∆∞·ª£t chuy·ªÉn h∆∞·ªõng
        missile.vx += (targetVx - missile.vx) * 0.1;
        missile.vy += (targetVy - missile.vy) * 0.1;
      }
    }
    
    // C·∫≠p nh·∫≠t v·ªã tr√≠ th·∫ø gi·ªõi
    missile.worldX += missile.vx;
    missile.worldY += missile.vy;
    
    // Th√™m ƒëi·ªÉm v√†o ƒëu√¥i kh√≥i
    missile.trailPoints.push({ x: missile.x, y: missile.y });
    if (missile.trailPoints.length > 10) {
      missile.trailPoints.shift();
    }
    
    // Ki·ªÉm tra va ch·∫°m v·ªõi k·∫ª ƒë·ªãch
    let hasHit = false;
    for (let j = enemies.length - 1; j >= 0; j--) {
      let enemy = enemies[j];
      let dx = enemy.x + 30 - missile.x;
      let dy = enemy.y + 35 - missile.y;
      let distance = Math.sqrt(dx * dx + dy * dy);
      
      if (distance < 30) { // Va ch·∫°m tr·ª±c ti·∫øp
        hasHit = true;
        
        // T·∫°o v·ª• n·ªï
        if (typeof window.missileExplosions === 'undefined') window.missileExplosions = [];
        window.missileExplosions.push({
          x: missile.x,
          y: missile.y,
          radius: 0,
          maxRadius: missileSystem.explosionRadius,
          time: 0,
          maxTime: 30
        });
        
        // G√¢y s√°t th∆∞∆°ng cho t·∫•t c·∫£ k·∫ª ƒë·ªãch trong ph·∫°m vi n·ªï
        for (let k = enemies.length - 1; k >= 0; k--) {
          let targetEnemy = enemies[k];
          let explosionDx = targetEnemy.x + 30 - missile.x;
          let explosionDy = targetEnemy.y + 35 - missile.y;
          let explosionDistance = Math.sqrt(explosionDx * explosionDx + explosionDy * explosionDy);
          
          if (explosionDistance <= missileSystem.explosionRadius) {
            targetEnemy.hp -= missileSystem.missileDamage;
            
            // Th√™m hi·ªáu ·ª©ng n·ªï cho t·ª´ng k·∫ª ƒë·ªãch b·ªã tr√∫ng
            if (typeof window.explosions === 'undefined') window.explosions = [];
            window.explosions.push({ x: targetEnemy.x, y: targetEnemy.y, time: 0 });
            
            if (targetEnemy.hp <= 0) {
              enemies.splice(k, 1);
              victorySystem.enemiesKilled++;
              
              if (victorySystem.enemiesKilled >= victorySystem.targetKills) {
                victorySystem.gameWon = true;
              }
            }
          }
        }
        
        break;
      }
    }
    
    // X√≥a t√™n l·ª≠a n·∫øu ra kh·ªèi m√†n h√¨nh ho·∫∑c ƒë√£ n·ªï
    if (hasHit || missile.y < -50 || missile.y > canvas.height + 50 || 
        missile.x < -50 || missile.x > canvas.width + 50) {
      missileSystem.missiles.splice(i, 1);
      continue;
    }
    
    // V·∫Ω t√™n l·ª≠a
    if (missile.x > -50 && missile.x < canvas.width + 50 && 
        missile.y > -50 && missile.y < canvas.height + 50) {
      drawMissile(missile);
    }
  }

  // V·∫Ω hi·ªáu ·ª©ng n·ªï t√™n l·ª≠a
  if (typeof window.missileExplosions !== 'undefined') {
    for (let i = window.missileExplosions.length - 1; i >= 0; i--) {
      let ex = window.missileExplosions[i];
      
      // TƒÉng b√°n k√≠nh n·ªï
      ex.radius = (ex.time / ex.maxTime) * ex.maxRadius;
      let opacity = 1 - (ex.time / ex.maxTime);
      
      if (ex.time <= ex.maxTime) {
        drawMissileExplosion(ex.x, ex.y, ex.radius, opacity);
      }
      
      ex.time++;
      if (ex.time > ex.maxTime) {
        window.missileExplosions.splice(i, 1);
      }
    }
  }

  // C·∫≠p nh·∫≠t cooldown t√™n l·ª≠a
  if (!missileSystem.isReady) {
    missileSystem.currentCooldown -= 16.67; // Gi·∫£ s·ª≠ 60 FPS
    if (missileSystem.currentCooldown <= 0) {
      missileSystem.isReady = true;
      updateMissileButton();
    }
  }

  // Hi·ªÉn th·ªã th√¥ng tin game
  ctx.save();
  ctx.font = 'bold 1.2em Arial';
  ctx.fillStyle = '#fff';
  ctx.shadowColor = '#000';
  ctx.shadowBlur = 3;
  ctx.fillText(`HP: ${tank.hp}/${tank.maxHp}`, 20, 20);
  ctx.fillText(`Ti√™u di·ªát: ${victorySystem.enemiesKilled}/${victorySystem.targetKills}`, 20, 40);
  
  // Hi·ªÉn th·ªã cooldown s√≥ng ƒëi·ªán
  if (!electricWaveSystem.isReady) {
    let cooldownSeconds = Math.ceil(electricWaveSystem.currentCooldown / 1000);
    ctx.fillStyle = '#8a2be2';
    ctx.fillText(`‚ö° S√≥ng ƒëi·ªán: ${cooldownSeconds}s`, 20, 60);
  } else {
    ctx.fillStyle = '#8a2be2';
    ctx.fillText(`‚ö° S√≥ng ƒëi·ªán: S·∫µn s√†ng`, 20, 60);
  }
  
  // Hi·ªÉn th·ªã cooldown t√™n l·ª≠a
  if (!missileSystem.isReady) {
    let cooldownSeconds = Math.ceil(missileSystem.currentCooldown / 1000);
    ctx.fillStyle = '#ff5722';
    ctx.fillText(`üöÄ T√™n l·ª≠a: ${cooldownSeconds}s`, 20, 80);
  } else {
    ctx.fillStyle = '#ff5722';
    ctx.fillText(`üöÄ T√™n l·ª≠a: S·∫µn s√†ng`, 20, 80);
  }
  ctx.restore();

  // H·ªá th·ªëng b√¨nh nhi√™n li·ªáu - kh√¥ng c√≥ th·ªùi gian ch·ªù
}

// Th√™m n√∫t ch∆°i l·∫°i
function showReplayButton() {
  let btn = document.getElementById('replayBtn');
  if (!btn) {
    btn = document.createElement('button');
    btn.id = 'replayBtn';
    btn.innerText = 'Ch∆°i l·∫°i';
    btn.style.position = 'fixed';
    btn.style.top = 'calc(50% + 60px)';
    btn.style.left = '50%';
    btn.style.transform = 'translate(-50%,0)';
    btn.style.fontSize = '2em';
    btn.style.padding = '0.5em 2em';
    btn.style.zIndex = '100';
    btn.style.background = '#2196f3';
    btn.style.color = '#fff';
    btn.style.border = 'none';
    btn.style.borderRadius = '15px';
    btn.style.boxShadow = '0 4px 15px rgba(0,0,0,0.3)';
    btn.style.cursor = 'pointer';
    document.body.appendChild(btn);
    btn.addEventListener('click', function() {
      // Reset tr·∫°ng th√°i game
      resetGame();
      btn.remove();
    });
  }
  btn.style.display = 'block';
}

// Hi·ªÉn th·ªã m√†n h√¨nh chi·∫øn th·∫Øng
function showVictoryScreen() {
  // Hi·ªáu ·ª©ng ph√°o hoa (c√≥ th·ªÉ th√™m sau)
  ctx.save();
  ctx.font = 'bold 3em Arial';
  ctx.fillStyle = '#FFD700';
  ctx.textAlign = 'center';
  ctx.shadowColor = '#000';
  ctx.shadowBlur = 10;
  ctx.fillText('üéâ CHI·∫æN TH·∫ÆNG! üéâ', canvas.width / 2, canvas.height / 2 - 50);
  
  ctx.font = 'bold 1.5em Arial';
  ctx.fillStyle = '#fff';
  ctx.fillText(`ƒê√£ ti√™u di·ªát ${victorySystem.targetKills} qu√¢n ƒë·ªãch!`, canvas.width / 2, canvas.height / 2 + 20);
  ctx.restore();
  
  // Hi·ªán n√∫t ch∆°i l·∫°i
  showReplayButton();
}

function resetGame() {
  // Reset c√°c bi·∫øn game
  tank.hp = tank.maxHp;
  tank.x = canvas.width/2 - 30;
  tank.y = canvas.height - 120;
  if (typeof tank.worldX !== 'undefined') tank.worldX = 0;
  if (typeof tank.worldY !== 'undefined') tank.worldY = 0;
  bullets = [];
  enemyBullets = [];
  enemies = [];
  window.explosions = [];
  window.tankExplosions = [];
  window.tankHitExplosions = [];
  window.electricExplosions = [];
  window.missileExplosions = [];
  frameCount = 0;
  enemyIdCounter = 0;
  gameStarted = true;
  
  // Reset h·ªá th·ªëng b√¨nh nhi√™n li·ªáu - lu√¥n s·∫µn s√†ng
  fuelSystem.isReady = true;
  updateFuelButton();
  
  // Reset h·ªá th·ªëng s√≥ng ƒëi·ªán
  electricWaveSystem.isReady = true;
  electricWaveSystem.currentCooldown = 0;
  electricWaveSystem.waves = [];
  updateElectricWaveButton();
  
  // Reset h·ªá th·ªëng t√™n l·ª≠a - lu√¥n s·∫µn s√†ng
  missileSystem.isReady = true;
  missileSystem.currentCooldown = 0;
  missileSystem.missiles = [];
  updateMissileButton();
  
  // Reset h·ªá th·ªëng chi·∫øn th·∫Øng
  victorySystem.enemiesKilled = 0;
  victorySystem.gameWon = false;
  // ·∫®n n√∫t replay n·∫øu c√≤n
  let btn = document.getElementById('replayBtn');
  if (btn) btn.style.display = 'none';
  // B·∫≠t l·∫°i controls n·∫øu c√≥
  if (joystickContainer) joystickContainer.style.display = 'block';
  if (shootControls) shootControls.style.display = 'block';
  // B·∫≠t l·∫°i nh·∫°c
  bgm.currentTime = 0;
  bgm.play();
  // Ch·∫°y l·∫°i game loop
  requestAnimationFrame(gameLoop);
}

    // X·ª≠ l√Ω ph√≠m m≈©i t√™n v√† b·∫Øn ƒë·∫°n
    // Smooth movement and shooting with key state
    const keys = {};
    document.addEventListener('keydown', function(e) {
      keys[e.key] = true;
      
      // Ph√≠m F ƒë·ªÉ s·ª≠ d·ª•ng b√¨nh nhi√™n li·ªáu
      if (e.key === 'f' || e.key === 'F') {
        useFuel();
      }
      
      // Ph√≠m E ƒë·ªÉ s·ª≠ d·ª•ng s√≥ng ƒëi·ªán
      if (e.key === 'e' || e.key === 'E') {
        useElectricWave();
      }
      
      // Ph√≠m s·ªë 1 ƒë·ªÉ s·ª≠ d·ª•ng t√™n l·ª≠a
      if (e.key === '1') {
        useMissile();
      }
    });
    document.addEventListener('keyup', function(e) {
      keys[e.key] = false;
    });

    // H·ªá th·ªëng b√¨nh nhi√™n li·ªáu
    const fuelSystem = {
      isReady: true,
      cooldownTime: 0, // Kh√¥ng c√≥ th·ªùi gian ch·ªù
      currentCooldown: 0
    };

    function useFuel() {
      if (fuelSystem.isReady && tank.hp < tank.maxHp) {
        tank.hp = Math.min(tank.hp + 2, tank.maxHp); // H·ªìi 2 m√°u
        // Kh√¥ng c√≥ th·ªùi gian ch·ªù, c√≥ th·ªÉ s·ª≠ d·ª•ng li√™n t·ª•c
        updateFuelButton();
      }
    }

    function updateFuelButton() {
      if (fuelSystem.isReady) {
        fuelBtn.classList.remove('disabled');
        fuelBtn.style.opacity = '1';
      } else {
        fuelBtn.classList.add('disabled');
        fuelBtn.style.opacity = '0.5';
      }
    }

    function initWorldSystem() {
      // ƒê·∫∑t offset ban ƒë·∫ßu ƒë·ªÉ xe tƒÉng ·ªü gi·ªØa m√†n h√¨nh
      worldSystem.offsetX = tank.worldX - (canvas.width / 2 - 30);
      worldSystem.offsetY = tank.worldY - (canvas.height / 2 - 25);
      
      // C·∫≠p nh·∫≠t v·ªã tr√≠ xe tƒÉng tr√™n m√†n h√¨nh
      tank.x = tank.worldX - worldSystem.offsetX;
      tank.y = tank.worldY - worldSystem.offsetY;
    }

    // Joystick v√† n√∫t b·∫Øn
    const joystick = {
      active: false,
      baseX: 0,
      baseY: 0,
      handleX: 0,
      handleY: 0,
      limitRadius: 0,
      dx: 0,
      dy: 0
    };
    
    const shootButton = document.getElementById('shootBtn');
    
    // X·ª≠ l√Ω s·ª± ki·ªán ƒëi·ªÅu khi·ªÉn
    function setupControls() {
      // Kh·ªüi t·∫°o joystick
      const baseRect = joystickBase.getBoundingClientRect();
      joystick.baseX = baseRect.left + baseRect.width / 2;
      joystick.baseY = baseRect.top + baseRect.height / 2;
      joystick.limitRadius = baseRect.width / 2 - joystickHandle.offsetWidth / 2;
      
      // ƒê·∫∑t handle v√†o gi·ªØa
      joystick.handleX = joystick.baseX;
      joystick.handleY = joystick.baseY;
      updateJoystickPosition();
      
      // Mouse events for joystick
      joystickHandle.addEventListener('mousedown', startJoystick);
      document.addEventListener('mousemove', moveJoystick);
      document.addEventListener('mouseup', endJoystick);
      
      // Touch events for joystick
      joystickHandle.addEventListener('touchstart', startJoystick);
      document.addEventListener('touchmove', moveJoystick);
      document.addEventListener('touchend', endJoystick);
      document.addEventListener('touchcancel', endJoystick);
      
      // N√∫t b·∫Øn
      shootButton.addEventListener('mousedown', () => keys[' '] = true);
      shootButton.addEventListener('mouseup', () => keys[' '] = false);
      shootButton.addEventListener('mouseleave', () => keys[' '] = false);
      
      // Touch events cho n√∫t b·∫Øn - h·ªó tr·ª£ gi·ªØ ƒë·ªÉ b·∫Øn li√™n t·ª•c
      shootButton.addEventListener('touchstart', (e) => { 
        e.preventDefault(); 
        keys[' '] = true; 
      });
      shootButton.addEventListener('touchend', (e) => { 
        e.preventDefault(); 
        keys[' '] = false; 
      });
      shootButton.addEventListener('touchcancel', (e) => { 
        e.preventDefault(); 
        keys[' '] = false; 
      });
      
      // N√∫t b√¨nh nhi√™n li·ªáu
      fuelBtn.addEventListener('click', useFuel);
      fuelBtn.addEventListener('touchstart', (e) => { e.preventDefault(); useFuel(); });
      
      // N√∫t s√≥ng ƒëi·ªán
      electricWaveBtn.addEventListener('click', useElectricWave);
      electricWaveBtn.addEventListener('touchstart', (e) => { e.preventDefault(); useElectricWave(); });
      
      // N√∫t t√™n l·ª≠a
      missileBtn.addEventListener('click', useMissile);
      missileBtn.addEventListener('touchstart', (e) => { e.preventDefault(); useMissile(); });
    }
    
    function startJoystick(e) {
      e.preventDefault();
      joystick.active = true;
      
      // Recalculate base position in case of screen resize
      const baseRect = joystickBase.getBoundingClientRect();
      joystick.baseX = baseRect.left + baseRect.width / 2;
      joystick.baseY = baseRect.top + baseRect.height / 2;
      joystick.limitRadius = baseRect.width / 2 - joystickHandle.offsetWidth / 2;
    }
    
    function moveJoystick(e) {
      if (!joystick.active) return;
      e.preventDefault();
      
      let clientX, clientY;
      
      if (e.type === 'touchmove') {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
      } else {
        clientX = e.clientX;
        clientY = e.clientY;
      }
      
      // Calculate distance from center
      let dx = clientX - joystick.baseX;
      let dy = clientY - joystick.baseY;
      let distance = Math.sqrt(dx * dx + dy * dy);
      
      // Limit to circle
      if (distance > joystick.limitRadius) {
        dx = dx * joystick.limitRadius / distance;
        dy = dy * joystick.limitRadius / distance;
      }
      
      // Update handle position
      joystick.handleX = joystick.baseX + dx;
      joystick.handleY = joystick.baseY + dy;
      
      // Update joystick values for game controls
      joystick.dx = dx / joystick.limitRadius; // -1 to 1
      joystick.dy = dy / joystick.limitRadius; // -1 to 1
      
      // Update visual position
      updateJoystickPosition();
      
      // Update key states based on joystick position
      updateKeyStates();
    }
    
    function endJoystick(e) {
      if (!joystick.active) return;
      e.preventDefault();
      joystick.active = false;
      
      // Reset joystick to center
      joystick.handleX = joystick.baseX;
      joystick.handleY = joystick.baseY;
      joystick.dx = 0;
      joystick.dy = 0;
      
      // Update visual position
      updateJoystickPosition();
      
      // Reset all direction keys
      keys['ArrowUp'] = false;
      keys['ArrowDown'] = false;
      keys['ArrowLeft'] = false;
      keys['ArrowRight'] = false;
    }
    
    function updateJoystickPosition() {
      joystickHandle.style.transform = `translate(${joystick.handleX - joystick.baseX}px, ${joystick.handleY - joystick.baseY}px)`;
    }
    
    function updateKeyStates() {
      // Convert joystick position to key presses
      const deadzone = 0.3; // Ignore small movements
      
      keys['ArrowUp'] = joystick.dy < -deadzone;
      keys['ArrowDown'] = joystick.dy > deadzone;
      keys['ArrowLeft'] = joystick.dx < -deadzone;
      keys['ArrowRight'] = joystick.dx > deadzone;
    }

    function gameLoop() {
      if (gameStarted) {
        update();
        requestAnimationFrame(gameLoop);
      }
    }

startBtn.addEventListener('click', function() {
      startBtn.style.display = 'none';
      canvas.style.display = 'block';
      joystickContainer.style.display = 'block';
      shootControls.style.display = 'block';
      gameStarted = true;
      
      // ƒê·∫£m b·∫£o canvas fullscreen
      resizeCanvas();
      
      // Kh·ªüi t·∫°o h·ªá th·ªëng th·∫ø gi·ªõi
      initWorldSystem();
      
      // Thi·∫øt l·∫≠p ƒëi·ªÅu khi·ªÉn joystick
      setupControls();
      
      // Kh·ªüi t·∫°o tr·∫°ng th√°i n√∫t b√¨nh nhi√™n li·ªáu
      updateFuelButton();
      
      // Kh·ªüi t·∫°o tr·∫°ng th√°i n√∫t s√≥ng ƒëi·ªán
      updateElectricWaveButton();
      
      // Kh·ªüi t·∫°o tr·∫°ng th√°i n√∫t t√™n l·ª≠a
      updateMissileButton();
      
      bgm.currentTime = 0;
      // Try to play audio, fallback if blocked
      bgm.play().then(() => {
        // success
      }).catch(() => {
        // If failed, show a message and try again on next user gesture
        alert('Click anywhere to enable game music!');
        document.body.addEventListener('click', function tryPlay() {
          bgm.play();
          document.body.removeEventListener('click', tryPlay);
        });
      });
      gameLoop();
    });
  </script>
</body>
</html>
