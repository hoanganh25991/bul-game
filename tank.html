<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>B·∫Øn Xe TƒÉng</title>
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#2196f3">
  <link rel="icon" type="image/png" href="icon-192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="icon-192.png">
  <link rel="icon" type="image/png" sizes="192x192" href="icon-192.png">
  <link rel="apple-touch-icon" href="icon-192.png">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <style>
    * {
      box-sizing: border-box;
    }
    
    body {
      background: #222;
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
      overflow: hidden;
      width: 100vw;
      height: 100vh;
    }
    
    .game-container {
      position: relative;
      width: 100vw;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    
    canvas {
      background: #444;
      width: 100vw;
      height: 100vh;
      display: block;
    }
    
    /* Joystick - g√≥c tr√°i */
    .joystick-container {
      position: fixed;
      bottom: 30px;
      left: 30px;
      display: none;
      z-index: 10;
      width: 150px;
      height: 150px;
      touch-action: none;
    }
    
    .joystick-base {
      position: absolute;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.2);
      border: 2px solid #fff;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(5px);
    }
    
    .joystick-handle {
      position: absolute;
      width: 60px;
      height: 60px;
      background: rgba(255, 255, 255, 0.5);
      border: 2px solid #fff;
      border-radius: 50%;
      cursor: pointer;
      user-select: none;
      transition: transform 0.1s;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-weight: bold;
    }
    
    /* N√∫t b·∫Øn v√† b√¨nh nhi√™n li·ªáu - g√≥c ph·∫£i */
    .shoot-controls {
      position: fixed;
      bottom: 30px;
      right: 30px;
      display: none;
      z-index: 10;
      flex-direction: row;
      gap: 20px;
      align-items: center;
    }
    
    .shoot-btn {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: rgba(255, 235, 59, 0.3);
      border: 3px solid #ffeb3b;
      color: #ffeb3b;
      font-size: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      user-select: none;
      transition: all 0.1s;
      touch-action: manipulation;
      backdrop-filter: blur(5px);
    }
    
    .shoot-btn:hover {
      background: rgba(255, 235, 59, 0.5);
      transform: scale(1.1);
    }
    
    .shoot-btn:active {
      background: rgba(255, 235, 59, 0.7);
      transform: scale(0.9);
    }
    
    /* N√∫t b√¨nh nhi√™n li·ªáu */
    .fuel-btn {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: rgba(76, 175, 80, 0.3);
      border: 3px solid #4caf50;
      color: #4caf50;
      font-size: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      user-select: none;
      transition: all 0.1s;
      touch-action: manipulation;
      backdrop-filter: blur(5px);
      margin-bottom: 10px;
    }
    
    .fuel-btn:hover {
      background: rgba(76, 175, 80, 0.5);
      transform: scale(1.1);
    }
    
    .fuel-btn:active {
      background: rgba(76, 175, 80, 0.7);
      transform: scale(0.9);
    }
    
    .fuel-btn.disabled {
      background: rgba(128, 128, 128, 0.3);
      border-color: #808080;
      color: #808080;
      cursor: not-allowed;
      opacity: 0.5;
    }
    
    .fuel-btn.disabled:hover {
      transform: none;
      background: rgba(128, 128, 128, 0.3);
    }
    
    /* Responsive cho m√†n h√¨nh nh·ªè */
    @media (max-width: 768px) {
      .joystick-container {
        width: 130px;
        height: 130px;
        bottom: 20px;
        left: 20px;
      }
      
      .joystick-handle {
        width: 50px;
        height: 50px;
      }
      
      .shoot-controls {
        bottom: 20px;
        right: 20px;
        gap: 15px;
      }
      
      .shoot-btn {
        width: 70px;
        height: 70px;
        font-size: 28px;
      }
      
      .fuel-btn {
        width: 70px;
        height: 70px;
        font-size: 28px;
      }
    }
    
    @media (max-width: 480px) {
      .joystick-container {
        width: 120px;
        height: 120px;
        bottom: 15px;
        left: 15px;
      }
      
      .joystick-handle {
        width: 45px;
        height: 45px;
      }
      
      .shoot-controls {
        bottom: 15px;
        right: 15px;
        gap: 12px;
      }
      
      .shoot-btn {
        width: 65px;
        height: 65px;
        font-size: 24px;
      }
      
      .fuel-btn {
        width: 65px;
        height: 65px;
        font-size: 24px;
      }
    }
    
    @media (max-width: 360px) {
      .joystick-container {
        width: 100px;
        height: 100px;
        bottom: 10px;
        left: 10px;
      }
      
      .joystick-handle {
        width: 40px;
        height: 40px;
      }
      
      .shoot-controls {
        bottom: 10px;
        right: 10px;
        gap: 10px;
      }
      
      .shoot-btn {
        width: 55px;
        height: 55px;
        font-size: 20px;
      }
      
      .fuel-btn {
        width: 55px;
        height: 55px;
        font-size: 20px;
      }
    }
  </style>
</head>
<body>
  <div class="game-container">
    <button id="startBtn" style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:2em;padding:0.8em 2em;z-index:20;border:none;background:#4caf50;color:#fff;border-radius:15px;cursor:pointer;box-shadow:0 4px 15px rgba(0,0,0,0.3);">üéÆ B·∫Øt ƒë·∫ßu</button>
    <canvas id="gameCanvas" style="display:none;"></canvas>
    
    <!-- Joystick - g√≥c tr√°i -->
    <div class="joystick-container" id="joystickContainer">
      <div class="joystick-base" id="joystickBase">
        <div class="joystick-handle" id="joystickHandle"></div>
      </div>
    </div>
    
    <!-- N√∫t b·∫Øn v√† b√¨nh nhi√™n li·ªáu - g√≥c ph·∫£i -->
    <div class="shoot-controls" id="shootControls">
      <button class="fuel-btn" id="fuelBtn">‚õΩ</button>
      <button class="shoot-btn" id="shootBtn"><img src="bullet.png" alt="Bullet" style="width: 30px; height: 30px;"></button>
    </div>
  </div>
  
  <audio id="bgm" src="my-love-don-t-let-love-fade.mp3" loop></audio>
  <script>

    // ƒêƒÉng k√Ω service worker cho PWA
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', function() {
        navigator.serviceWorker.register('sw.js').then(function(reg) {
          // Service worker registered
        }, function(err) {
          // Registration failed
        });
      });
    }

    const startBtn = document.getElementById('startBtn');
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const bgm = document.getElementById('bgm');
    const joystickContainer = document.getElementById('joystickContainer');
    const joystickBase = document.getElementById('joystickBase');
    const joystickHandle = document.getElementById('joystickHandle');
    const shootControls = document.getElementById('shootControls');
    const fuelBtn = document.getElementById('fuelBtn');
    
    // Thi·∫øt l·∫≠p canvas fullscreen
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    
    // G·ªçi resize khi t·∫£i trang v√† khi thay ƒë·ªïi k√≠ch th∆∞·ªõc
    window.addEventListener('resize', function() {
      if (gameStarted) {
        resizeCanvas();
      }
    });
    resizeCanvas();

    let gameStarted = false;
    
    // H·ªá th·ªëng chi·∫øn th·∫Øng
    const victorySystem = {
      enemiesKilled: 0,
      targetKills: 30,
      gameWon: false
    };

    // H·ªá th·ªëng b·∫£n ƒë·ªì v√¥ t·∫≠n
    const worldSystem = {
      offsetX: 0,
      offsetY: 0,
      tileSize: 40,
      terrain: [],
      decorations: []
    };

    // Sinh ƒë·ªãa h√¨nh v√† trang tr√≠
    function generateTerrain(startX, startY, width, height) {
      for (let x = startX; x < startX + width; x++) {
        for (let y = startY; y < startY + height; y++) {
          let key = `${x},${y}`;
          if (!worldSystem.terrain[key]) {
            // Sinh ƒë·ªãa h√¨nh c∆° b·∫£n
            let terrainType = 'grass';
            if (Math.random() < 0.1) terrainType = 'dirt';
            else if (Math.random() < 0.05) terrainType = 'stone';
            
            worldSystem.terrain[key] = {
              type: terrainType,
              x: x,
              y: y
            };
            
            // Sinh trang tr√≠
            if (Math.random() < 0.08) {
              let decorationType = 'grass_tuft';
              if (Math.random() < 0.3) decorationType = 'small_rock';
              else if (Math.random() < 0.1) decorationType = 'tree';
              else if (Math.random() < 0.2) decorationType = 'bush';
              
              worldSystem.decorations.push({
                type: decorationType,
                x: x * worldSystem.tileSize + Math.random() * worldSystem.tileSize,
                y: y * worldSystem.tileSize + Math.random() * worldSystem.tileSize,
                size: 0.5 + Math.random() * 0.5
              });
            }
          }
        }
      }
    }

    // V·∫Ω ƒë·ªãa h√¨nh
    function drawTerrain() {
      const startTileX = Math.floor(worldSystem.offsetX / worldSystem.tileSize) - 1;
      const startTileY = Math.floor(worldSystem.offsetY / worldSystem.tileSize) - 1;
      const endTileX = startTileX + Math.ceil(canvas.width / worldSystem.tileSize) + 2;
      const endTileY = startTileY + Math.ceil(canvas.height / worldSystem.tileSize) + 2;
      
      // Sinh th√™m ƒë·ªãa h√¨nh n·∫øu c·∫ßn
      generateTerrain(startTileX, startTileY, endTileX - startTileX, endTileY - startTileY);
      
      // V·∫Ω ƒë·ªãa h√¨nh
      for (let x = startTileX; x < endTileX; x++) {
        for (let y = startTileY; y < endTileY; y++) {
          let key = `${x},${y}`;
          let terrain = worldSystem.terrain[key];
          if (terrain) {
            let screenX = x * worldSystem.tileSize - worldSystem.offsetX;
            let screenY = y * worldSystem.tileSize - worldSystem.offsetY;
            
            switch (terrain.type) {
              case 'grass':
                ctx.fillStyle = '#4a7c59';
                break;
              case 'dirt':
                ctx.fillStyle = '#8b4513';
                break;
              case 'stone':
                ctx.fillStyle = '#696969';
                break;
            }
            ctx.fillRect(screenX, screenY, worldSystem.tileSize, worldSystem.tileSize);
          }
        }
      }
    }

    // V·∫Ω trang tr√≠
    function drawDecorations() {
      for (let decoration of worldSystem.decorations) {
        let screenX = decoration.x - worldSystem.offsetX;
        let screenY = decoration.y - worldSystem.offsetY;
        
        // Ch·ªâ v·∫Ω n·∫øu trong ph·∫°m vi m√†n h√¨nh
        if (screenX > -50 && screenX < canvas.width + 50 && 
            screenY > -50 && screenY < canvas.height + 50) {
          
          ctx.save();
          let size = decoration.size * 20;
          
          switch (decoration.type) {
            case 'grass_tuft':
              ctx.fillStyle = '#228B22';
              ctx.beginPath();
              for (let i = 0; i < 5; i++) {
                let angle = (i / 5) * Math.PI * 2;
                let x = screenX + Math.cos(angle) * size * 0.3;
                let y = screenY + Math.sin(angle) * size * 0.2;
                ctx.lineTo(x, y);
              }
              ctx.fill();
              break;
              
            case 'small_rock':
              ctx.fillStyle = '#A0A0A0';
              ctx.beginPath();
              ctx.arc(screenX, screenY, size * 0.4, 0, Math.PI * 2);
              ctx.fill();
              ctx.fillStyle = '#808080';
              ctx.beginPath();
              ctx.arc(screenX - size * 0.1, screenY - size * 0.1, size * 0.2, 0, Math.PI * 2);
              ctx.fill();
              break;
              
            case 'tree':
              // Th√¢n c√¢y
              ctx.fillStyle = '#8B4513';
              ctx.fillRect(screenX - size * 0.1, screenY - size * 0.3, size * 0.2, size * 0.6);
              // L√° c√¢y
              ctx.fillStyle = '#228B22';
              ctx.beginPath();
              ctx.arc(screenX, screenY - size * 0.3, size * 0.4, 0, Math.PI * 2);
              ctx.fill();
              break;
              
            case 'bush':
              ctx.fillStyle = '#32CD32';
              ctx.beginPath();
              ctx.arc(screenX, screenY, size * 0.3, 0, Math.PI * 2);
              ctx.fill();
              ctx.fillStyle = '#228B22';
              ctx.beginPath();
              ctx.arc(screenX - size * 0.1, screenY - size * 0.1, size * 0.2, 0, Math.PI * 2);
              ctx.fill();
              break;
          }
          ctx.restore();
        }
      }
    }

    const tank = {
        x: 400, // V·ªã tr√≠ tr√™n m√†n h√¨nh
        y: 300, // V·ªã tr√≠ tr√™n m√†n h√¨nh
        speed: 5,
        hp: 5,
        maxHp: 5,
        worldX: 400, // V·ªã tr√≠ th·ª±c trong th·∫ø gi·ªõi
        worldY: 300
    };


    let bullets = [];
    const bulletSpeed = 7;

    // ƒê·∫°n c·ªßa xe tƒÉng ƒë·ªãch
    let enemyBullets = [];
    const enemyBulletSpeed = 4;


    function drawBullet(bullet, color = '#ffeb3b') {
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(bullet.x, bullet.y, 5, 0, Math.PI * 2);
      ctx.fill();
    }

    function drawExplosion(x, y) {
      ctx.save();
      ctx.beginPath();
      ctx.arc(x + 30, y + 35, 25, 0, Math.PI * 2);
      ctx.fillStyle = 'orange';
      ctx.globalAlpha = 0.7;
      ctx.fill();
      ctx.beginPath();
      ctx.arc(x + 30, y + 35, 12, 0, Math.PI * 2);
      ctx.fillStyle = 'yellow';
      ctx.globalAlpha = 0.9;
      ctx.fill();
      ctx.globalAlpha = 1;
      ctx.restore();
    }

function drawTank(x, y, color = '#4caf50', turretColor = '#388e3c', reverse = false, hp, maxHp) {
  // reverse = false: xe tƒÉng h∆∞·ªõng l√™n, true: h∆∞·ªõng xu·ªëng
  ctx.save();
  if (reverse) {
    ctx.translate(x + 30, y + 35);
    ctx.rotate(Math.PI);
    ctx.translate(-x - 30, -y - 35);
  }
  // V·∫Ω c·ªôt m√°u n·∫øu c√≥ hp v√† maxHp (∆∞u ti√™n v·∫Ω tr∆∞·ªõc ƒë·ªÉ kh√¥ng b·ªã che)
  if (typeof hp === 'number' && typeof maxHp === 'number') {
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.strokeRect(x + 5, y - 15, 50, 7);
    // Thanh m√°u n·ªÅn
    ctx.fillStyle = '#f44336';
    ctx.fillRect(x + 5, y - 15, 50, 7);
    // ƒê·ªïi m√†u health bar theo ph·∫ßn trƒÉm m√°u
    let percent = Math.max(0, Math.min(1, hp / maxHp));
    if (percent > 0.6) ctx.fillStyle = '#76ff03'; // xanh
    else if (percent > 0.3) ctx.fillStyle = '#ffeb3b'; // v√†ng
    else ctx.fillStyle = '#f44336'; // ƒë·ªè
    ctx.fillRect(x + 5, y - 15, 50 * percent, 7);
  }
  // Th√¢n xe
  ctx.fillStyle = color;
  ctx.fillRect(x, y + 20, 60, 30);
  // Th√°p ph√°o
  ctx.fillStyle = turretColor;
  ctx.fillRect(x + 15, y, 30, 30);
  // N√≤ng ph√°o
  ctx.fillStyle = '#222';
  ctx.fillRect(x + 27, y - 20, 6, 20);
  // B√°nh xe
  ctx.fillStyle = '#222';
  for (let i = 0; i < 3; i++) {
    ctx.beginPath();
    ctx.arc(x + 15 + i * 15, y + 50, 8, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.restore();
}
// Enemy tanks
let enemies = [];
const enemySpeed = 2;
const enemySpawnInterval = 120; // frames
let frameCount = 0;

function spawnEnemy() {
  // Random x position trong th·∫ø gi·ªõi, spawn ph√≠a tr√™n tank
  const x = Math.floor(Math.random() * (canvas.width - 60));
  const worldX = x + worldSystem.offsetX;
  const worldY = worldSystem.offsetY - 100; // Spawn ph√≠a tr√™n v√πng nh√¨n th·∫•y
  
  // enemy s·∫Ω c√≥ h∆∞·ªõng di chuy·ªÉn ng·∫´u nhi√™n ban ƒë·∫ßu
  const dx = Math.random() < 0.5 ? enemySpeed : -enemySpeed;
  const dy = 1.5; // t·ªëc ƒë·ªô xu·ªëng ·ªïn ƒë·ªãnh
  
  // Th√™m h·ªá th·ªëng m√°u cho xe tƒÉng ƒë·ªãch v√† v·ªã tr√≠ th·∫ø gi·ªõi
  enemies.push({ 
    x: x, 
    y: -100, 
    dx: dx, 
    dy: dy, 
    hp: 3, 
    maxHp: 3,
    worldX: worldX,
    worldY: worldY
  });
}

    function clear() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

function update() {
  clear();
  
  // V·∫Ω b·∫£n ƒë·ªì v√¥ t·∫≠n
  drawTerrain();
  drawDecorations();
  
  // Hi·ªáu ·ª©ng n·ªï cho tank ng∆∞·ªùi ch∆°i
  if (typeof window.tankExplosions === 'undefined') window.tankExplosions = [];

  // Ki·ªÉm tra chi·∫øn th·∫Øng
  if (victorySystem.gameWon) {
    showVictoryScreen();
    return;
  }
  
  // N·∫øu ƒë√£ thua th√¨ v·∫Ω n·ªï v√† th√¥ng b√°o, kh√¥ng update n·ªØa
  if (tank.hp <= 0) {
    // V·∫Ω hi·ªáu ·ª©ng n·ªï nhi·ªÅu frame
    if (window.tankExplosions.length === 0) {
      for (let i = 0; i < 20; i++) {
        window.tankExplosions.push({ x: tank.x, y: tank.y, time: i * 2 });
      }
    }
    for (let i = window.tankExplosions.length - 1; i >= 0; i--) {
      let ex = window.tankExplosions[i];
      if (ex.time <= 30) drawExplosion(ex.x, ex.y);
      ex.time++;
      if (ex.time > 30) window.tankExplosions.splice(i, 1);
    }
    ctx.save();
    ctx.font = 'bold 2.2em Arial';
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'center';
    ctx.shadowColor = '#000';
    ctx.shadowBlur = 8;
    ctx.fillText('B·∫°n ƒë√£ thua tr√≤ ch∆°i', canvas.width / 2, canvas.height / 2);
    ctx.restore();
    // Hi·ªán n√∫t ch∆°i l·∫°i
    showReplayButton();
    return;
// Th√™m n√∫t ch∆°i l·∫°i
function showReplayButton() {
  let btn = document.getElementById('replayBtn');
  if (!btn) {
    btn = document.createElement('button');
    btn.id = 'replayBtn';
    btn.innerText = 'Ch∆°i l·∫°i';
    btn.style.position = 'fixed';
    btn.style.top = 'calc(50% + 60px)';
    btn.style.left = '50%';
    btn.style.transform = 'translate(-50%,0)';
    btn.style.fontSize = '2em';
    btn.style.padding = '0.5em 2em';
    btn.style.zIndex = '100';
    btn.style.background = '#2196f3';
    btn.style.color = '#fff';
    btn.style.border = 'none';
    btn.style.borderRadius = '15px';
    btn.style.boxShadow = '0 4px 15px rgba(0,0,0,0.3)';
    btn.style.cursor = 'pointer';
    document.body.appendChild(btn);
    btn.addEventListener('click', function() {
      // Reset tr·∫°ng th√°i game
      resetGame();
      btn.remove();
    });
  }
  btn.style.display = 'block';
}

// Hi·ªÉn th·ªã m√†n h√¨nh chi·∫øn th·∫Øng
function showVictoryScreen() {
  // Hi·ªáu ·ª©ng ph√°o hoa (c√≥ th·ªÉ th√™m sau)
  ctx.save();
  ctx.font = 'bold 3em Arial';
  ctx.fillStyle = '#FFD700';
  ctx.textAlign = 'center';
  ctx.shadowColor = '#000';
  ctx.shadowBlur = 10;
  ctx.fillText('üéâ CHI·∫æN TH·∫ÆNG! üéâ', canvas.width / 2, canvas.height / 2 - 50);
  
  ctx.font = 'bold 1.5em Arial';
  ctx.fillStyle = '#fff';
  ctx.fillText(`ƒê√£ ti√™u di·ªát ${victorySystem.targetKills} qu√¢n ƒë·ªãch!`, canvas.width / 2, canvas.height / 2 + 20);
  ctx.restore();
  
  // Hi·ªán n√∫t ch∆°i l·∫°i
  showReplayButton();
}

function resetGame() {
  // Reset c√°c bi·∫øn game
  tank.hp = tank.maxHp;
  tank.x = canvas.width/2 - 30;
  tank.y = canvas.height - 120;
  if (typeof tank.worldX !== 'undefined') tank.worldX = 0;
  if (typeof tank.worldY !== 'undefined') tank.worldY = 0;
  bullets = [];
  enemyBullets = [];
  enemies = [];
  window.explosions = [];
  window.tankExplosions = [];
  window.tankHitExplosions = [];
  frameCount = 0;
  gameStarted = true;
  
  // Reset h·ªá th·ªëng b√¨nh nhi√™n li·ªáu
  fuelSystem.currentCooldown = 0;
  fuelSystem.isReady = true;
  updateFuelButton();
  
  // Reset h·ªá th·ªëng chi·∫øn th·∫Øng
  victorySystem.enemiesKilled = 0;
  victorySystem.gameWon = false;
  // ·∫®n n√∫t replay n·∫øu c√≤n
  let btn = document.getElementById('replayBtn');
  if (btn) btn.style.display = 'none';
  // B·∫≠t l·∫°i controls n·∫øu c√≥
  if (joystickContainer) joystickContainer.style.display = 'block';
  if (shootControls) shootControls.style.display = 'block';
  // B·∫≠t l·∫°i nh·∫°c
  bgm.currentTime = 0;
  bgm.play();
  // Ch·∫°y l·∫°i game loop
  requestAnimationFrame(gameLoop);
}
  } else {
    window.tankExplosions = [];
  }
  
  // Smooth tank movement v·ªõi h·ªá th·ªëng th·∫ø gi·ªõi v√¥ t·∫≠n
  let newWorldX = tank.worldX;
  let newWorldY = tank.worldY;
  
  if (keys['ArrowLeft']) {
    newWorldX -= tank.speed;
  }
  if (keys['ArrowRight']) {
    newWorldX += tank.speed;
  }
  if (keys['ArrowUp']) {
    newWorldY -= tank.speed;
  }
  if (keys['ArrowDown']) {
    newWorldY += tank.speed;
  }
  
  // C·∫≠p nh·∫≠t v·ªã tr√≠ th·∫ø gi·ªõi
  tank.worldX = newWorldX;
  tank.worldY = newWorldY;
  
  // Gi·ªØ xe tƒÉng ·ªü trung t√¢m m√†n h√¨nh khi c√≥ th·ªÉ
  let targetX = canvas.width / 2 - 30; // trung t√¢m - n·ª≠a chi·ªÅu r·ªông xe tƒÉng
  let targetY = canvas.height / 2 - 25; // trung t√¢m - n·ª≠a chi·ªÅu cao xe tƒÉng
  
  // T√≠nh to√°n offset ƒë·ªÉ gi·ªØ xe tƒÉng ·ªü v·ªã tr√≠ mong mu·ªën
  // Cho ph√©p xe tƒÉng di chuy·ªÉn t·ª± do trong th·∫ø gi·ªõi v√¥ t·∫≠n
  worldSystem.offsetX = tank.worldX - targetX;
  worldSystem.offsetY = tank.worldY - targetY;
  
  // C·∫≠p nh·∫≠t v·ªã tr√≠ xe tƒÉng tr√™n m√†n h√¨nh
  tank.x = tank.worldX - worldSystem.offsetX;
  tank.y = tank.worldY - worldSystem.offsetY;
  
  // Gi·ªõi h·∫°n xe tƒÉng trong m√†n h√¨nh (ch·ªâ khi c·∫ßn thi·∫øt)
  tank.x = Math.max(0, Math.min(canvas.width - 60, tank.x));
  tank.y = Math.max(0, Math.min(canvas.height - 50, tank.y));
  // Shooting when holding space
  if ((keys[' '] || keys['Spacebar']) && shootCooldown <= 0) {
    bullets.push({
      x: tank.x + 30,
      y: tank.y - 20,
      worldX: tank.worldX + 30,
      worldY: tank.worldY - 20
    });
    shootCooldown = 10; // frames between shots (adjust for faster/slower shooting)
  }
  if (shootCooldown > 0) shootCooldown--;

  // V·∫Ω xe tƒÉng ng∆∞·ªùi ch∆°i v·ªõi c·ªôt m√°u
  drawTank(tank.x, tank.y, '#4caf50', '#388e3c', false, tank.hp, tank.maxHp);
  
  // Hi·ªÉn th·ªã s·ªë qu√¢n ƒë·ªãch ƒë√£ ti√™u di·ªát
  ctx.save();
  ctx.font = 'bold 24px Arial';
  ctx.fillStyle = '#fff';
  ctx.textAlign = 'left';
  ctx.shadowColor = '#000';
  ctx.shadowBlur = 3;
  ctx.fillText(`Ti√™u di·ªát: ${victorySystem.enemiesKilled}/${victorySystem.targetKills}`, 20, 40);
  ctx.restore();
  
  // C·∫≠p nh·∫≠t v√† v·∫Ω ƒë·∫°n ng∆∞·ªùi ch∆°i
  for (let i = 0; i < bullets.length; i++) {
    bullets[i].worldY -= bulletSpeed;
    bullets[i].x = bullets[i].worldX - worldSystem.offsetX;
    bullets[i].y = bullets[i].worldY - worldSystem.offsetY;
    drawBullet(bullets[i]);
  }
  bullets = bullets.filter(b => b.y > -10 && b.y < canvas.height + 10);

  // C·∫≠p nh·∫≠t v√† v·∫Ω ƒë·∫°n enemy
  for (let i = 0; i < enemyBullets.length; i++) {
    enemyBullets[i].worldY += enemyBulletSpeed;
    enemyBullets[i].x = enemyBullets[i].worldX - worldSystem.offsetX;
    enemyBullets[i].y = enemyBullets[i].worldY - worldSystem.offsetY;
    drawBullet(enemyBullets[i], '#ff5252');
  }
  // Ki·ªÉm tra va ch·∫°m ƒë·∫°n ƒë·ªãch v·ªõi tank ng∆∞·ªùi ch∆°i
  for (let i = enemyBullets.length - 1; i >= 0; i--) {
    let b = enemyBullets[i];
    // Va ch·∫°m h√¨nh ch·ªØ nh·∫≠t v·ªõi tank
    if (
      b.x > tank.x && b.x < tank.x + 60 &&
      b.y > tank.y && b.y < tank.y + 50
    ) {
      tank.hp = Math.max(0, tank.hp - 1);
      // Hi·ªáu ·ª©ng n·ªï nh·ªè khi tr√∫ng ƒë·∫°n
      if (typeof window.tankHitExplosions === 'undefined') window.tankHitExplosions = [];
      window.tankHitExplosions.push({ x: tank.x, y: tank.y, time: 0 });
      enemyBullets.splice(i, 1);
      // N·∫øu m√°u v·ªÅ 0 th√¨ d·ª´ng game ·ªü frame n√†y
      if (tank.hp <= 0) {
        break;
      }
    }
  }
  enemyBullets = enemyBullets.filter(b => b.y > -10 && b.y < canvas.height + 10);

  // V·∫Ω hi·ªáu ·ª©ng n·ªï nh·ªè khi tr√∫ng ƒë·∫°n
  if (typeof window.tankHitExplosions === 'undefined') window.tankHitExplosions = [];
  for (let i = window.tankHitExplosions.length - 1; i >= 0; i--) {
    let ex = window.tankHitExplosions[i];
    if (ex.time < 10) drawExplosion(ex.x, ex.y);
    ex.time++;
    if (ex.time > 10) window.tankHitExplosions.splice(i, 1);
  }

  // Ki·ªÉm tra va ch·∫°m ƒë·∫°n ng∆∞·ªùi ch∆°i v√† xe tƒÉng ƒë·ªãch
  let explosions = [];
  for (let i = enemies.length - 1; i >= 0; i--) {
    let enemy = enemies[i];
    for (let j = bullets.length - 1; j >= 0; j--) {
      let bullet = bullets[j];
      // Ki·ªÉm tra va ch·∫°m h√¨nh ch·ªØ nh·∫≠t ƒë∆°n gi·∫£n
      if (
        bullet.x > enemy.x && bullet.x < enemy.x + 60 &&
        bullet.y > enemy.y && bullet.y < enemy.y + 50
      ) {
        // Gi·∫£m m√°u xe tƒÉng ƒë·ªãch
        enemy.hp = Math.max(0, enemy.hp - 1);
        
        // X√≥a ƒë·∫°n
        bullets.splice(j, 1);
        
        // N·∫øu m√°u v·ªÅ 0 th√¨ th√™m hi·ªáu ·ª©ng n·ªï v√† x√≥a xe tƒÉng
        if (enemy.hp <= 0) {
          explosions.push({ x: enemy.x, y: enemy.y, time: 0 });
          enemies.splice(i, 1);
          
          // TƒÉng s·ªë qu√¢n ƒë·ªãch ƒë√£ ti√™u di·ªát
          victorySystem.enemiesKilled++;
          
          // Ki·ªÉm tra ƒëi·ªÅu ki·ªán chi·∫øn th·∫Øng
          if (victorySystem.enemiesKilled >= victorySystem.targetKills) {
            victorySystem.gameWon = true;
          }
        }
        break;
      }
    }
  }

  // C·∫≠p nh·∫≠t v√† v·∫Ω qu√¢n ƒë·ªãch
  for (let i = 0; i < enemies.length; i++) {
    let enemy = enemies[i];
    
    const followRange = 80;
    const speed = Math.abs(enemy.dx);
    
    // T√≠nh v·ªã tr√≠ m√†n h√¨nh hi·ªán t·∫°i ƒë·ªÉ ki·ªÉm tra logic
    let currentScreenX = enemy.worldX - worldSystem.offsetX;
    let currentScreenY = enemy.worldY - worldSystem.offsetY;
    
    // Logic di chuy·ªÉn m∆∞·ª£t m√†
    let moveX = enemy.dx;
    let moveY = enemy.dy;
    
    // N·∫øu tank ·ªü g·∫ßn tr·ª•c x v√† enemy c√≤n ph√≠a tr√™n tank, th√¨ d√≠ theo
    if (Math.abs((currentScreenX + 30) - (tank.x + 30)) < followRange && currentScreenY < tank.y + 50) {
      // Di chuy·ªÉn m∆∞·ª£t v·ªÅ ph√≠a tank v·ªõi dead zone ƒë·ªÉ tr√°nh rung
      const distance = (tank.worldX + 30) - (enemy.worldX + 30);
      if (Math.abs(distance) > 10) { // Dead zone 10 pixels
        if (distance > 0) {
          moveX = Math.min(speed, Math.abs(distance) * 0.1); // Di chuy·ªÉn v·ªÅ ph√≠a ph·∫£i
        } else {
          moveX = -Math.min(speed, Math.abs(distance) * 0.1); // Di chuy·ªÉn v·ªÅ ph√≠a tr√°i
        }
      } else {
        moveX = 0; // ƒê·ª©ng y√™n khi trong dead zone
      }
    }
    
    // C·∫≠p nh·∫≠t v·ªã tr√≠ world m·ªôt c√°ch m∆∞·ª£t m√†
    enemy.worldX += moveX;
    enemy.worldY += moveY;
    
    // C·∫≠p nh·∫≠t v·ªã tr√≠ m√†n h√¨nh
    enemy.x = enemy.worldX - worldSystem.offsetX;
    enemy.y = enemy.worldY - worldSystem.offsetY;
    
    // C·∫≠p nh·∫≠t h∆∞·ªõng di chuy·ªÉn cho frame ti·∫øp theo
    enemy.dx = moveX;
    
    // V·∫Ω xe tƒÉng ƒë·ªãch n·∫øu trong ph·∫°m vi m√†n h√¨nh
    if (enemy.x > -70 && enemy.x < canvas.width + 70 && 
        enemy.y > -70 && enemy.y < canvas.height + 70) {
      drawTank(enemy.x, enemy.y, '#2196f3', '#1565c0', true, enemy.hp, enemy.maxHp);
    }

    // Enemy b·∫Øn ƒë·∫°n ƒë·ªãnh k·ª≥ v·ªõi t·∫ßn su·∫•t ·ªïn ƒë·ªãnh
    if (!enemy.shootTimer) enemy.shootTimer = Math.floor(Math.random() * 90) + 60; // TƒÉng th·ªùi gian delay
    enemy.shootTimer--;
    if (enemy.shootTimer <= 0) {
      enemyBullets.push({
        x: enemy.x + 30,
        y: enemy.y + 50,
        worldX: enemy.worldX + 30,
        worldY: enemy.worldY + 50
      });
      enemy.shootTimer = Math.floor(Math.random() * 90) + 60; // TƒÉng th·ªùi gian delay
    }
  }
  // X√≥a qu√¢n ƒë·ªãch ra kh·ªèi m·∫£ng n·∫øu ra kh·ªèi khu v·ª±c r·ªông h∆°n
  enemies = enemies.filter(e => 
    e.worldX > worldSystem.offsetX - 200 && e.worldX < worldSystem.offsetX + canvas.width + 200 &&
    e.worldY > worldSystem.offsetY - 200 && e.worldY < worldSystem.offsetY + canvas.height + 200
  );

  // V·∫Ω hi·ªáu ·ª©ng n·ªï
  if (typeof window.explosions === 'undefined') window.explosions = [];
  window.explosions = (window.explosions || []).concat(explosions || []);
  for (let i = window.explosions.length - 1; i >= 0; i--) {
    let ex = window.explosions[i];
    drawExplosion(ex.x, ex.y);
    ex.time++;
    if (ex.time > 15) window.explosions.splice(i, 1);
  }

  // Sinh qu√¢n ƒë·ªãch m·ªõi theo th·ªùi gian
  frameCount++;
  if (frameCount % enemySpawnInterval === 0) {
    spawnEnemy();
  }
  
  // C·∫≠p nh·∫≠t cooldown b√¨nh nhi√™n li·ªáu
  if (fuelSystem.currentCooldown > 0) {
    fuelSystem.currentCooldown--;
    if (fuelSystem.currentCooldown <= 0) {
      fuelSystem.isReady = true;
    }
    updateFuelButton();
  }
}

    // X·ª≠ l√Ω ph√≠m m≈©i t√™n v√† b·∫Øn ƒë·∫°n
    // Smooth movement and shooting with key state
    const keys = {};
    document.addEventListener('keydown', function(e) {
      keys[e.key] = true;
      
      // Ph√≠m F ƒë·ªÉ s·ª≠ d·ª•ng b√¨nh nhi√™n li·ªáu
      if (e.key === 'f' || e.key === 'F') {
        useFuel();
      }
    });
    document.addEventListener('keyup', function(e) {
      keys[e.key] = false;
    });

    // Shooting cooldown
    let shootCooldown = 0;
    
    // H·ªá th·ªëng b√¨nh nhi√™n li·ªáu
    const fuelSystem = {
      cooldownTime: 300, // 5 gi√¢y (60 FPS * 5)
      currentCooldown: 0,
      isReady: true
    };
    
    // H√†m s·ª≠ d·ª•ng b√¨nh nhi√™n li·ªáu
    function useFuel() {
      if (fuelSystem.isReady && tank.hp < tank.maxHp) {
        // H·ªìi ph·ª•c to√†n b·ªô HP
        tank.hp = tank.maxHp;
        
        // B·∫Øt ƒë·∫ßu cooldown
        fuelSystem.currentCooldown = fuelSystem.cooldownTime;
        fuelSystem.isReady = false;
        
        // C·∫≠p nh·∫≠t giao di·ªán n√∫t
        updateFuelButton();
        
        // Hi·ªáu ·ª©ng h·ªìi ph·ª•c (c√≥ th·ªÉ th√™m sau)
        console.log('ƒê√£ h·ªìi ph·ª•c to√†n b·ªô HP!');
      }
    }
    
    // C·∫≠p nh·∫≠t tr·∫°ng th√°i n√∫t b√¨nh nhi√™n li·ªáu
    function updateFuelButton() {
      if (fuelSystem.isReady) {
        fuelBtn.classList.remove('disabled');
        fuelBtn.innerHTML = '‚õΩ';
      } else {
        fuelBtn.classList.add('disabled');
        const secondsLeft = Math.ceil(fuelSystem.currentCooldown / 60);
        fuelBtn.innerHTML = secondsLeft.toString();
      }
    }
    
    // Kh·ªüi t·∫°o h·ªá th·ªëng th·∫ø gi·ªõi
    function initWorldSystem() {
      // ƒê·∫∑t offset ban ƒë·∫ßu ƒë·ªÉ xe tƒÉng ·ªü gi·ªØa m√†n h√¨nh
      worldSystem.offsetX = tank.worldX - (canvas.width / 2 - 30);
      worldSystem.offsetY = tank.worldY - (canvas.height / 2 - 25);
      
      // C·∫≠p nh·∫≠t v·ªã tr√≠ xe tƒÉng tr√™n m√†n h√¨nh
      tank.x = tank.worldX - worldSystem.offsetX;
      tank.y = tank.worldY - worldSystem.offsetY;
    }

    // Joystick v√† n√∫t b·∫Øn
    const joystick = {
      active: false,
      baseX: 0,
      baseY: 0,
      handleX: 0,
      handleY: 0,
      limitRadius: 0,
      dx: 0,
      dy: 0
    };
    
    const shootButton = document.getElementById('shootBtn');
    
    // X·ª≠ l√Ω s·ª± ki·ªán ƒëi·ªÅu khi·ªÉn
    function setupControls() {
      // Kh·ªüi t·∫°o joystick
      const baseRect = joystickBase.getBoundingClientRect();
      joystick.baseX = baseRect.left + baseRect.width / 2;
      joystick.baseY = baseRect.top + baseRect.height / 2;
      joystick.limitRadius = baseRect.width / 2 - joystickHandle.offsetWidth / 2;
      
      // ƒê·∫∑t handle v√†o gi·ªØa
      joystick.handleX = joystick.baseX;
      joystick.handleY = joystick.baseY;
      updateJoystickPosition();
      
      // Mouse events for joystick
      joystickHandle.addEventListener('mousedown', startJoystick);
      document.addEventListener('mousemove', moveJoystick);
      document.addEventListener('mouseup', endJoystick);
      
      // Touch events for joystick
      joystickHandle.addEventListener('touchstart', startJoystick);
      document.addEventListener('touchmove', moveJoystick);
      document.addEventListener('touchend', endJoystick);
      document.addEventListener('touchcancel', endJoystick);
      
      // N√∫t b·∫Øn
      shootButton.addEventListener('mousedown', () => keys[' '] = true);
      shootButton.addEventListener('mouseup', () => keys[' '] = false);
      shootButton.addEventListener('mouseleave', () => keys[' '] = false);
      
      shootButton.addEventListener('touchstart', (e) => { e.preventDefault(); keys[' '] = true; });
      shootButton.addEventListener('touchend', (e) => { e.preventDefault(); keys[' '] = false; });
      
      // N√∫t b√¨nh nhi√™n li·ªáu
      fuelBtn.addEventListener('click', useFuel);
      fuelBtn.addEventListener('touchstart', (e) => { e.preventDefault(); useFuel(); });
    }
    
    function startJoystick(e) {
      e.preventDefault();
      joystick.active = true;
      
      // Recalculate base position in case of screen resize
      const baseRect = joystickBase.getBoundingClientRect();
      joystick.baseX = baseRect.left + baseRect.width / 2;
      joystick.baseY = baseRect.top + baseRect.height / 2;
      joystick.limitRadius = baseRect.width / 2 - joystickHandle.offsetWidth / 2;
    }
    
    function moveJoystick(e) {
      if (!joystick.active) return;
      e.preventDefault();
      
      let clientX, clientY;
      
      if (e.type === 'touchmove') {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
      } else {
        clientX = e.clientX;
        clientY = e.clientY;
      }
      
      // Calculate distance from center
      let dx = clientX - joystick.baseX;
      let dy = clientY - joystick.baseY;
      let distance = Math.sqrt(dx * dx + dy * dy);
      
      // Limit to circle
      if (distance > joystick.limitRadius) {
        dx = dx * joystick.limitRadius / distance;
        dy = dy * joystick.limitRadius / distance;
      }
      
      // Update handle position
      joystick.handleX = joystick.baseX + dx;
      joystick.handleY = joystick.baseY + dy;
      
      // Update joystick values for game controls
      joystick.dx = dx / joystick.limitRadius; // -1 to 1
      joystick.dy = dy / joystick.limitRadius; // -1 to 1
      
      // Update visual position
      updateJoystickPosition();
      
      // Update key states based on joystick position
      updateKeyStates();
    }
    
    function endJoystick(e) {
      if (!joystick.active) return;
      e.preventDefault();
      joystick.active = false;
      
      // Reset joystick to center
      joystick.handleX = joystick.baseX;
      joystick.handleY = joystick.baseY;
      joystick.dx = 0;
      joystick.dy = 0;
      
      // Update visual position
      updateJoystickPosition();
      
      // Reset all direction keys
      keys['ArrowUp'] = false;
      keys['ArrowDown'] = false;
      keys['ArrowLeft'] = false;
      keys['ArrowRight'] = false;
    }
    
    function updateJoystickPosition() {
      joystickHandle.style.transform = `translate(${joystick.handleX - joystick.baseX}px, ${joystick.handleY - joystick.baseY}px)`;
    }
    
    function updateKeyStates() {
      // Convert joystick position to key presses
      const deadzone = 0.3; // Ignore small movements
      
      keys['ArrowUp'] = joystick.dy < -deadzone;
      keys['ArrowDown'] = joystick.dy > deadzone;
      keys['ArrowLeft'] = joystick.dx < -deadzone;
      keys['ArrowRight'] = joystick.dx > deadzone;
    }

    function gameLoop() {
      if (gameStarted) {
        update();
        requestAnimationFrame(gameLoop);
      }
    }

startBtn.addEventListener('click', function() {
      startBtn.style.display = 'none';
      canvas.style.display = 'block';
      joystickContainer.style.display = 'block';
      shootControls.style.display = 'block';
      gameStarted = true;
      
      // ƒê·∫£m b·∫£o canvas fullscreen
      resizeCanvas();
      
      // Kh·ªüi t·∫°o h·ªá th·ªëng th·∫ø gi·ªõi
      initWorldSystem();
      
      // Thi·∫øt l·∫≠p ƒëi·ªÅu khi·ªÉn joystick
      setupControls();
      
      // Kh·ªüi t·∫°o tr·∫°ng th√°i n√∫t b√¨nh nhi√™n li·ªáu
      updateFuelButton();
      
      bgm.currentTime = 0;
      // Try to play audio, fallback if blocked
      bgm.play().then(() => {
        // success
      }).catch(() => {
        // If failed, show a message and try again on next user gesture
        alert('Click anywhere to enable game music!');
        document.body.addEventListener('click', function tryPlay() {
          bgm.play();
          document.body.removeEventListener('click', tryPlay);
        });
      });
      gameLoop();
    });
  </script>
</body>
</html>
