<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>B·∫Øn Xe TƒÉng</title>
  <style>
    * {
      box-sizing: border-box;
    }
    
    body {
      background: #222;
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
      overflow: hidden;
      width: 100vw;
      height: 100vh;
    }
    
    .game-container {
      position: relative;
      width: 100vw;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    
    canvas {
      background: #444;
      width: 100vw;
      height: 100vh;
      display: block;
    }
    
    /* ƒêi·ªÅu khi·ªÉn di chuy·ªÉn - g√≥c tr√°i */
    .movement-controls {
      position: fixed;
      bottom: 30px;
      left: 30px;
      display: none;
      grid-template-columns: repeat(3, 60px);
      grid-template-rows: repeat(3, 60px);
      gap: 5px;
      z-index: 10;
    }
    
    .control-btn {
      background: rgba(255, 255, 255, 0.2);
      border: 2px solid #fff;
      border-radius: 12px;
      color: #fff;
      font-size: 20px;
      font-weight: bold;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      transition: all 0.1s;
      touch-action: manipulation;
      backdrop-filter: blur(5px);
    }
    
    .control-btn:hover {
      background: rgba(255, 255, 255, 0.3);
      transform: scale(1.05);
    }
    
    .control-btn:active {
      background: rgba(255, 255, 255, 0.5);
      transform: scale(0.95);
    }
    
    .up-btn { grid-column: 2; grid-row: 1; }
    .left-btn { grid-column: 1; grid-row: 2; }
    .right-btn { grid-column: 3; grid-row: 2; }
    .down-btn { grid-column: 2; grid-row: 3; }
    
    /* N√∫t b·∫Øn - g√≥c ph·∫£i */
    .shoot-controls {
      position: fixed;
      bottom: 30px;
      right: 30px;
      display: none;
      z-index: 10;
    }
    
    .shoot-btn {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: rgba(255, 235, 59, 0.3);
      border: 3px solid #ffeb3b;
      color: #ffeb3b;
      font-size: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      user-select: none;
      transition: all 0.1s;
      touch-action: manipulation;
      backdrop-filter: blur(5px);
    }
    
    .shoot-btn:hover {
      background: rgba(255, 235, 59, 0.5);
      transform: scale(1.1);
    }
    
    .shoot-btn:active {
      background: rgba(255, 235, 59, 0.7);
      transform: scale(0.9);
    }
    
    /* Responsive cho m√†n h√¨nh nh·ªè */
    @media (max-width: 768px) {
      .movement-controls {
        grid-template-columns: repeat(3, 55px);
        grid-template-rows: repeat(3, 55px);
        bottom: 20px;
        left: 20px;
      }
      
      .control-btn {
        font-size: 18px;
      }
      
      .shoot-controls {
        bottom: 20px;
        right: 20px;
      }
      
      .shoot-btn {
        width: 70px;
        height: 70px;
        font-size: 28px;
      }
    }
    
    @media (max-width: 480px) {
      .movement-controls {
        grid-template-columns: repeat(3, 50px);
        grid-template-rows: repeat(3, 50px);
        bottom: 15px;
        left: 15px;
      }
      
      .control-btn {
        font-size: 16px;
      }
      
      .shoot-controls {
        bottom: 15px;
        right: 15px;
      }
      
      .shoot-btn {
        width: 65px;
        height: 65px;
        font-size: 24px;
      }
    }
    
    @media (max-width: 360px) {
      .movement-controls {
        grid-template-columns: repeat(3, 45px);
        grid-template-rows: repeat(3, 45px);
        bottom: 10px;
        left: 10px;
      }
      
      .control-btn {
        font-size: 14px;
      }
      
      .shoot-controls {
        bottom: 10px;
        right: 10px;
      }
      
      .shoot-btn {
        width: 55px;
        height: 55px;
        font-size: 20px;
      }
    }
  </style>
</head>
<body>
  <div class="game-container">
    <button id="startBtn" style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:2em;padding:0.8em 2em;z-index:20;border:none;background:#4caf50;color:#fff;border-radius:15px;cursor:pointer;box-shadow:0 4px 15px rgba(0,0,0,0.3);">üéÆ B·∫Øt ƒë·∫ßu</button>
    <canvas id="gameCanvas" style="display:none;"></canvas>
    
    <!-- ƒêi·ªÅu khi·ªÉn di chuy·ªÉn - g√≥c tr√°i -->
    <div class="movement-controls" id="movementControls">
      <button class="control-btn up-btn" id="upBtn">‚Üë</button>
      <button class="control-btn left-btn" id="leftBtn">‚Üê</button>
      <button class="control-btn right-btn" id="rightBtn">‚Üí</button>
      <button class="control-btn down-btn" id="downBtn">‚Üì</button>
    </div>
    
    <!-- N√∫t b·∫Øn - g√≥c ph·∫£i -->
    <div class="shoot-controls" id="shootControls">
      <button class="shoot-btn" id="shootBtn">üî•</button>
    </div>
  </div>
  
  <audio id="bgm" src="my-love-don-t-let-love-fade.mp3" loop></audio>
  <script>

    const startBtn = document.getElementById('startBtn');
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const bgm = document.getElementById('bgm');
    const movementControls = document.getElementById('movementControls');
    const shootControls = document.getElementById('shootControls');
    
    // Thi·∫øt l·∫≠p canvas fullscreen
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    
    // G·ªçi resize khi t·∫£i trang v√† khi thay ƒë·ªïi k√≠ch th∆∞·ªõc
    window.addEventListener('resize', function() {
      if (gameStarted) {
        resizeCanvas();
      }
    });
    resizeCanvas();

    let gameStarted = false;

    // H·ªá th·ªëng b·∫£n ƒë·ªì v√¥ t·∫≠n
    const worldSystem = {
      offsetX: 0,
      offsetY: 0,
      tileSize: 40,
      terrain: [],
      decorations: []
    };

    // Sinh ƒë·ªãa h√¨nh v√† trang tr√≠
    function generateTerrain(startX, startY, width, height) {
      for (let x = startX; x < startX + width; x++) {
        for (let y = startY; y < startY + height; y++) {
          let key = `${x},${y}`;
          if (!worldSystem.terrain[key]) {
            // Sinh ƒë·ªãa h√¨nh c∆° b·∫£n
            let terrainType = 'grass';
            if (Math.random() < 0.1) terrainType = 'dirt';
            else if (Math.random() < 0.05) terrainType = 'stone';
            
            worldSystem.terrain[key] = {
              type: terrainType,
              x: x,
              y: y
            };
            
            // Sinh trang tr√≠
            if (Math.random() < 0.08) {
              let decorationType = 'grass_tuft';
              if (Math.random() < 0.3) decorationType = 'small_rock';
              else if (Math.random() < 0.1) decorationType = 'tree';
              else if (Math.random() < 0.2) decorationType = 'bush';
              
              worldSystem.decorations.push({
                type: decorationType,
                x: x * worldSystem.tileSize + Math.random() * worldSystem.tileSize,
                y: y * worldSystem.tileSize + Math.random() * worldSystem.tileSize,
                size: 0.5 + Math.random() * 0.5
              });
            }
          }
        }
      }
    }

    // V·∫Ω ƒë·ªãa h√¨nh
    function drawTerrain() {
      const startTileX = Math.floor(worldSystem.offsetX / worldSystem.tileSize) - 1;
      const startTileY = Math.floor(worldSystem.offsetY / worldSystem.tileSize) - 1;
      const endTileX = startTileX + Math.ceil(canvas.width / worldSystem.tileSize) + 2;
      const endTileY = startTileY + Math.ceil(canvas.height / worldSystem.tileSize) + 2;
      
      // Sinh th√™m ƒë·ªãa h√¨nh n·∫øu c·∫ßn
      generateTerrain(startTileX, startTileY, endTileX - startTileX, endTileY - startTileY);
      
      // V·∫Ω ƒë·ªãa h√¨nh
      for (let x = startTileX; x < endTileX; x++) {
        for (let y = startTileY; y < endTileY; y++) {
          let key = `${x},${y}`;
          let terrain = worldSystem.terrain[key];
          if (terrain) {
            let screenX = x * worldSystem.tileSize - worldSystem.offsetX;
            let screenY = y * worldSystem.tileSize - worldSystem.offsetY;
            
            switch (terrain.type) {
              case 'grass':
                ctx.fillStyle = '#4a7c59';
                break;
              case 'dirt':
                ctx.fillStyle = '#8b4513';
                break;
              case 'stone':
                ctx.fillStyle = '#696969';
                break;
            }
            ctx.fillRect(screenX, screenY, worldSystem.tileSize, worldSystem.tileSize);
          }
        }
      }
    }

    // V·∫Ω trang tr√≠
    function drawDecorations() {
      for (let decoration of worldSystem.decorations) {
        let screenX = decoration.x - worldSystem.offsetX;
        let screenY = decoration.y - worldSystem.offsetY;
        
        // Ch·ªâ v·∫Ω n·∫øu trong ph·∫°m vi m√†n h√¨nh
        if (screenX > -50 && screenX < canvas.width + 50 && 
            screenY > -50 && screenY < canvas.height + 50) {
          
          ctx.save();
          let size = decoration.size * 20;
          
          switch (decoration.type) {
            case 'grass_tuft':
              ctx.fillStyle = '#228B22';
              ctx.beginPath();
              for (let i = 0; i < 5; i++) {
                let angle = (i / 5) * Math.PI * 2;
                let x = screenX + Math.cos(angle) * size * 0.3;
                let y = screenY + Math.sin(angle) * size * 0.2;
                ctx.lineTo(x, y);
              }
              ctx.fill();
              break;
              
            case 'small_rock':
              ctx.fillStyle = '#A0A0A0';
              ctx.beginPath();
              ctx.arc(screenX, screenY, size * 0.4, 0, Math.PI * 2);
              ctx.fill();
              ctx.fillStyle = '#808080';
              ctx.beginPath();
              ctx.arc(screenX - size * 0.1, screenY - size * 0.1, size * 0.2, 0, Math.PI * 2);
              ctx.fill();
              break;
              
            case 'tree':
              // Th√¢n c√¢y
              ctx.fillStyle = '#8B4513';
              ctx.fillRect(screenX - size * 0.1, screenY - size * 0.3, size * 0.2, size * 0.6);
              // L√° c√¢y
              ctx.fillStyle = '#228B22';
              ctx.beginPath();
              ctx.arc(screenX, screenY - size * 0.3, size * 0.4, 0, Math.PI * 2);
              ctx.fill();
              break;
              
            case 'bush':
              ctx.fillStyle = '#32CD32';
              ctx.beginPath();
              ctx.arc(screenX, screenY, size * 0.3, 0, Math.PI * 2);
              ctx.fill();
              ctx.fillStyle = '#228B22';
              ctx.beginPath();
              ctx.arc(screenX - size * 0.1, screenY - size * 0.1, size * 0.2, 0, Math.PI * 2);
              ctx.fill();
              break;
          }
          ctx.restore();
        }
      }
    }

    const tank = {
        x: 400, // V·ªã tr√≠ tr√™n m√†n h√¨nh
        y: 300, // V·ªã tr√≠ tr√™n m√†n h√¨nh
        speed: 5,
        hp: 5,
        maxHp: 5,
        worldX: 400, // V·ªã tr√≠ th·ª±c trong th·∫ø gi·ªõi
        worldY: 300
    };


    let bullets = [];
    const bulletSpeed = 7;

    // ƒê·∫°n c·ªßa xe tƒÉng ƒë·ªãch
    let enemyBullets = [];
    const enemyBulletSpeed = 4;


    function drawBullet(bullet, color = '#ffeb3b') {
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(bullet.x, bullet.y, 5, 0, Math.PI * 2);
      ctx.fill();
    }

    function drawExplosion(x, y) {
      ctx.save();
      ctx.beginPath();
      ctx.arc(x + 30, y + 35, 25, 0, Math.PI * 2);
      ctx.fillStyle = 'orange';
      ctx.globalAlpha = 0.7;
      ctx.fill();
      ctx.beginPath();
      ctx.arc(x + 30, y + 35, 12, 0, Math.PI * 2);
      ctx.fillStyle = 'yellow';
      ctx.globalAlpha = 0.9;
      ctx.fill();
      ctx.globalAlpha = 1;
      ctx.restore();
    }

function drawTank(x, y, color = '#4caf50', turretColor = '#388e3c', reverse = false, hp, maxHp) {
  // reverse = false: xe tƒÉng h∆∞·ªõng l√™n, true: h∆∞·ªõng xu·ªëng
  ctx.save();
  if (reverse) {
    ctx.translate(x + 30, y + 35);
    ctx.rotate(Math.PI);
    ctx.translate(-x - 30, -y - 35);
  }
  // V·∫Ω c·ªôt m√°u n·∫øu c√≥ hp v√† maxHp (∆∞u ti√™n v·∫Ω tr∆∞·ªõc ƒë·ªÉ kh√¥ng b·ªã che)
  if (typeof hp === 'number' && typeof maxHp === 'number') {
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.strokeRect(x + 5, y - 15, 50, 7);
    // Thanh m√°u n·ªÅn
    ctx.fillStyle = '#f44336';
    ctx.fillRect(x + 5, y - 15, 50, 7);
    // ƒê·ªïi m√†u health bar theo ph·∫ßn trƒÉm m√°u
    let percent = Math.max(0, Math.min(1, hp / maxHp));
    if (percent > 0.6) ctx.fillStyle = '#76ff03'; // xanh
    else if (percent > 0.3) ctx.fillStyle = '#ffeb3b'; // v√†ng
    else ctx.fillStyle = '#f44336'; // ƒë·ªè
    ctx.fillRect(x + 5, y - 15, 50 * percent, 7);
  }
  // Th√¢n xe
  ctx.fillStyle = color;
  ctx.fillRect(x, y + 20, 60, 30);
  // Th√°p ph√°o
  ctx.fillStyle = turretColor;
  ctx.fillRect(x + 15, y, 30, 30);
  // N√≤ng ph√°o
  ctx.fillStyle = '#222';
  ctx.fillRect(x + 27, y - 20, 6, 20);
  // B√°nh xe
  ctx.fillStyle = '#222';
  for (let i = 0; i < 3; i++) {
    ctx.beginPath();
    ctx.arc(x + 15 + i * 15, y + 50, 8, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.restore();
}
// Enemy tanks
let enemies = [];
const enemySpeed = 2;
const enemySpawnInterval = 120; // frames
let frameCount = 0;

function spawnEnemy() {
  // Random x position, y = -50 (tr√™n m√†n h√¨nh), random h∆∞·ªõng di chuy·ªÉn
  const x = Math.floor(Math.random() * (canvas.width - 60));
  // enemy s·∫Ω c√≥ h∆∞·ªõng di chuy·ªÉn ng·∫´u nhi√™n ban ƒë·∫ßu
  const dx = Math.random() < 0.5 ? enemySpeed : -enemySpeed;
  const dy = 1.2; // t·ªëc ƒë·ªô xu·ªëng ch·∫≠m h∆°n ƒë·ªÉ m∆∞·ª£t
  // Th√™m h·ªá th·ªëng m√°u cho xe tƒÉng ƒë·ªãch v√† v·ªã tr√≠ th·∫ø gi·ªõi
  enemies.push({ 
    x: x, 
    y: -50, 
    dx: dx, 
    dy: dy, 
    hp: 3, 
    maxHp: 3,
    worldX: x + worldSystem.offsetX,
    worldY: -50 + worldSystem.offsetY
  });
}

    function clear() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

function update() {
  clear();
  
  // V·∫Ω b·∫£n ƒë·ªì v√¥ t·∫≠n
  drawTerrain();
  drawDecorations();
  
  // Hi·ªáu ·ª©ng n·ªï cho tank ng∆∞·ªùi ch∆°i
  if (typeof window.tankExplosions === 'undefined') window.tankExplosions = [];

  // N·∫øu ƒë√£ thua th√¨ v·∫Ω n·ªï v√† th√¥ng b√°o, kh√¥ng update n·ªØa
  if (tank.hp <= 0) {
    // V·∫Ω hi·ªáu ·ª©ng n·ªï nhi·ªÅu frame
    if (window.tankExplosions.length === 0) {
      for (let i = 0; i < 20; i++) {
        window.tankExplosions.push({ x: tank.x, y: tank.y, time: i * 2 });
      }
    }
    for (let i = window.tankExplosions.length - 1; i >= 0; i--) {
      let ex = window.tankExplosions[i];
      if (ex.time <= 30) drawExplosion(ex.x, ex.y);
      ex.time++;
      if (ex.time > 30) window.tankExplosions.splice(i, 1);
    }
    ctx.save();
    ctx.font = 'bold 2.2em Arial';
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'center';
    ctx.shadowColor = '#000';
    ctx.shadowBlur = 8;
    ctx.fillText('B·∫°n ƒë√£ thua tr√≤ ch∆°i', canvas.width / 2, canvas.height / 2);
    ctx.restore();
    return;
  } else {
    window.tankExplosions = [];
  }
  
  // Smooth tank movement v·ªõi h·ªá th·ªëng th·∫ø gi·ªõi v√¥ t·∫≠n
  let newWorldX = tank.worldX;
  let newWorldY = tank.worldY;
  
  if (keys['ArrowLeft']) {
    newWorldX -= tank.speed;
  }
  if (keys['ArrowRight']) {
    newWorldX += tank.speed;
  }
  if (keys['ArrowUp']) {
    newWorldY -= tank.speed;
  }
  if (keys['ArrowDown']) {
    newWorldY += tank.speed;
  }
  
  // C·∫≠p nh·∫≠t v·ªã tr√≠ th·∫ø gi·ªõi
  tank.worldX = newWorldX;
  tank.worldY = newWorldY;
  
  // Gi·ªØ xe tƒÉng ·ªü trung t√¢m m√†n h√¨nh khi c√≥ th·ªÉ
  let targetX = canvas.width / 2 - 30; // trung t√¢m - n·ª≠a chi·ªÅu r·ªông xe tƒÉng
  let targetY = canvas.height / 2 - 25; // trung t√¢m - n·ª≠a chi·ªÅu cao xe tƒÉng
  
  // T√≠nh to√°n offset ƒë·ªÉ gi·ªØ xe tƒÉng ·ªü v·ªã tr√≠ mong mu·ªën
  // Cho ph√©p xe tƒÉng di chuy·ªÉn t·ª± do trong th·∫ø gi·ªõi v√¥ t·∫≠n
  worldSystem.offsetX = tank.worldX - targetX;
  worldSystem.offsetY = tank.worldY - targetY;
  
  // C·∫≠p nh·∫≠t v·ªã tr√≠ xe tƒÉng tr√™n m√†n h√¨nh
  tank.x = tank.worldX - worldSystem.offsetX;
  tank.y = tank.worldY - worldSystem.offsetY;
  
  // Gi·ªõi h·∫°n xe tƒÉng trong m√†n h√¨nh (ch·ªâ khi c·∫ßn thi·∫øt)
  tank.x = Math.max(0, Math.min(canvas.width - 60, tank.x));
  tank.y = Math.max(0, Math.min(canvas.height - 50, tank.y));
  // Shooting when holding space
  if ((keys[' '] || keys['Spacebar']) && shootCooldown <= 0) {
    bullets.push({
      x: tank.x + 30,
      y: tank.y - 20,
      worldX: tank.worldX + 30,
      worldY: tank.worldY - 20
    });
    shootCooldown = 10; // frames between shots (adjust for faster/slower shooting)
  }
  if (shootCooldown > 0) shootCooldown--;

  // V·∫Ω xe tƒÉng ng∆∞·ªùi ch∆°i v·ªõi c·ªôt m√°u
  drawTank(tank.x, tank.y, '#4caf50', '#388e3c', false, tank.hp, tank.maxHp);
  
  // C·∫≠p nh·∫≠t v√† v·∫Ω ƒë·∫°n ng∆∞·ªùi ch∆°i
  for (let i = 0; i < bullets.length; i++) {
    bullets[i].worldY -= bulletSpeed;
    bullets[i].x = bullets[i].worldX - worldSystem.offsetX;
    bullets[i].y = bullets[i].worldY - worldSystem.offsetY;
    drawBullet(bullets[i]);
  }
  bullets = bullets.filter(b => b.y > -10 && b.y < canvas.height + 10);

  // C·∫≠p nh·∫≠t v√† v·∫Ω ƒë·∫°n enemy
  for (let i = 0; i < enemyBullets.length; i++) {
    enemyBullets[i].worldY += enemyBulletSpeed;
    enemyBullets[i].x = enemyBullets[i].worldX - worldSystem.offsetX;
    enemyBullets[i].y = enemyBullets[i].worldY - worldSystem.offsetY;
    drawBullet(enemyBullets[i], '#ff5252');
  }
  // Ki·ªÉm tra va ch·∫°m ƒë·∫°n ƒë·ªãch v·ªõi tank ng∆∞·ªùi ch∆°i
  for (let i = enemyBullets.length - 1; i >= 0; i--) {
    let b = enemyBullets[i];
    // Va ch·∫°m h√¨nh ch·ªØ nh·∫≠t v·ªõi tank
    if (
      b.x > tank.x && b.x < tank.x + 60 &&
      b.y > tank.y && b.y < tank.y + 50
    ) {
      tank.hp = Math.max(0, tank.hp - 1);
      // Hi·ªáu ·ª©ng n·ªï nh·ªè khi tr√∫ng ƒë·∫°n
      if (typeof window.tankHitExplosions === 'undefined') window.tankHitExplosions = [];
      window.tankHitExplosions.push({ x: tank.x, y: tank.y, time: 0 });
      enemyBullets.splice(i, 1);
      // N·∫øu m√°u v·ªÅ 0 th√¨ d·ª´ng game ·ªü frame n√†y
      if (tank.hp <= 0) {
        break;
      }
    }
  }
  enemyBullets = enemyBullets.filter(b => b.y > -10 && b.y < canvas.height + 10);

  // V·∫Ω hi·ªáu ·ª©ng n·ªï nh·ªè khi tr√∫ng ƒë·∫°n
  if (typeof window.tankHitExplosions === 'undefined') window.tankHitExplosions = [];
  for (let i = window.tankHitExplosions.length - 1; i >= 0; i--) {
    let ex = window.tankHitExplosions[i];
    if (ex.time < 10) drawExplosion(ex.x, ex.y);
    ex.time++;
    if (ex.time > 10) window.tankHitExplosions.splice(i, 1);
  }

  // Ki·ªÉm tra va ch·∫°m ƒë·∫°n ng∆∞·ªùi ch∆°i v√† xe tƒÉng ƒë·ªãch
  let explosions = [];
  for (let i = enemies.length - 1; i >= 0; i--) {
    let enemy = enemies[i];
    for (let j = bullets.length - 1; j >= 0; j--) {
      let bullet = bullets[j];
      // Ki·ªÉm tra va ch·∫°m h√¨nh ch·ªØ nh·∫≠t ƒë∆°n gi·∫£n
      if (
        bullet.x > enemy.x && bullet.x < enemy.x + 60 &&
        bullet.y > enemy.y && bullet.y < enemy.y + 50
      ) {
        // Gi·∫£m m√°u xe tƒÉng ƒë·ªãch
        enemy.hp = Math.max(0, enemy.hp - 1);
        
        // X√≥a ƒë·∫°n
        bullets.splice(j, 1);
        
        // N·∫øu m√°u v·ªÅ 0 th√¨ th√™m hi·ªáu ·ª©ng n·ªï v√† x√≥a xe tƒÉng
        if (enemy.hp <= 0) {
          explosions.push({ x: enemy.x, y: enemy.y, time: 0 });
          enemies.splice(i, 1);
        }
        break;
      }
    }
  }

  // C·∫≠p nh·∫≠t v√† v·∫Ω qu√¢n ƒë·ªãch
  for (let i = 0; i < enemies.length; i++) {
    let enemy = enemies[i];
    
    // C·∫≠p nh·∫≠t v·ªã tr√≠ world
    enemy.worldX += enemy.dx;
    enemy.worldY += enemy.dy;
    
    // C·∫≠p nh·∫≠t v·ªã tr√≠ m√†n h√¨nh
    enemy.x = enemy.worldX - worldSystem.offsetX;
    enemy.y = enemy.worldY - worldSystem.offsetY;
    
    const followRange = 80;
    const speed = Math.abs(enemy.dx);
    
    // N·∫øu tank ·ªü g·∫ßn tr·ª•c x v√† enemy c√≤n ph√≠a tr√™n tank, th√¨ d√≠ theo
    if (Math.abs((enemy.x + 30) - (tank.x + 30)) < followRange && enemy.y < tank.y + 50) {
      // Di chuy·ªÉn m∆∞·ª£t v·ªÅ ph√≠a tank
      if (enemy.worldX + 30 < tank.worldX + 30 - 2) {
        enemy.worldX += speed;
        enemy.dx = Math.abs(enemy.dx);
      } else if (enemy.worldX + 30 > tank.worldX + 30 + 2) {
        enemy.worldX -= speed;
        enemy.dx = -Math.abs(enemy.dx);
      }
    }
    
    // V·∫Ω xe tƒÉng ƒë·ªãch n·∫øu trong ph·∫°m vi m√†n h√¨nh
    if (enemy.x > -70 && enemy.x < canvas.width + 70 && 
        enemy.y > -70 && enemy.y < canvas.height + 70) {
      drawTank(enemy.x, enemy.y, '#2196f3', '#1565c0', true, enemy.hp, enemy.maxHp);
    }

    // Enemy b·∫Øn ƒë·∫°n ƒë·ªãnh k·ª≥
    if (!enemy.shootTimer) enemy.shootTimer = Math.floor(Math.random() * 60) + 40; // random delay
    enemy.shootTimer--;
    if (enemy.shootTimer <= 0) {
      enemyBullets.push({
        x: enemy.x + 30,
        y: enemy.y + 50,
        worldX: enemy.worldX + 30,
        worldY: enemy.worldY + 50
      });
      enemy.shootTimer = Math.floor(Math.random() * 60) + 40; // random l·∫°i cho l·∫ßn sau
    }
  }
  // X√≥a qu√¢n ƒë·ªãch ra kh·ªèi m·∫£ng n·∫øu ra kh·ªèi khu v·ª±c r·ªông h∆°n
  enemies = enemies.filter(e => 
    e.worldX > worldSystem.offsetX - 200 && e.worldX < worldSystem.offsetX + canvas.width + 200 &&
    e.worldY > worldSystem.offsetY - 200 && e.worldY < worldSystem.offsetY + canvas.height + 200
  );

  // V·∫Ω hi·ªáu ·ª©ng n·ªï
  if (typeof window.explosions === 'undefined') window.explosions = [];
  window.explosions = (window.explosions || []).concat(explosions || []);
  for (let i = window.explosions.length - 1; i >= 0; i--) {
    let ex = window.explosions[i];
    drawExplosion(ex.x, ex.y);
    ex.time++;
    if (ex.time > 15) window.explosions.splice(i, 1);
  }

  // Sinh qu√¢n ƒë·ªãch m·ªõi theo th·ªùi gian
  frameCount++;
  if (frameCount % enemySpawnInterval === 0) {
    // Sinh enemy ·ªü ph√≠a tr√™n v√πng nh√¨n th·∫•y
    const x = Math.floor(Math.random() * (canvas.width - 60));
    const dx = Math.random() < 0.5 ? enemySpeed : -enemySpeed;
    const dy = 1.2;
    enemies.push({ 
      x: x, 
      y: -100, 
      dx: dx, 
      dy: dy, 
      hp: 3, 
      maxHp: 3,
      worldX: x + worldSystem.offsetX,
      worldY: -100 + worldSystem.offsetY
    });
  }
}

    // X·ª≠ l√Ω ph√≠m m≈©i t√™n v√† b·∫Øn ƒë·∫°n
    // Smooth movement and shooting with key state
    const keys = {};
    document.addEventListener('keydown', function(e) {
      keys[e.key] = true;
    });
    document.addEventListener('keyup', function(e) {
      keys[e.key] = false;
    });

    // Shooting cooldown
    let shootCooldown = 0;
    
    // Kh·ªüi t·∫°o h·ªá th·ªëng th·∫ø gi·ªõi
    function initWorldSystem() {
      // ƒê·∫∑t offset ban ƒë·∫ßu ƒë·ªÉ xe tƒÉng ·ªü gi·ªØa m√†n h√¨nh
      worldSystem.offsetX = tank.worldX - (canvas.width / 2 - 30);
      worldSystem.offsetY = tank.worldY - (canvas.height / 2 - 25);
      
      // C·∫≠p nh·∫≠t v·ªã tr√≠ xe tƒÉng tr√™n m√†n h√¨nh
      tank.x = tank.worldX - worldSystem.offsetX;
      tank.y = tank.worldY - worldSystem.offsetY;
    }

    // ƒêi·ªÅu khi·ªÉn b·∫±ng n√∫t
    const controlButtons = {
      up: document.getElementById('upBtn'),
      left: document.getElementById('leftBtn'),
      right: document.getElementById('rightBtn'),
      down: document.getElementById('downBtn'),
      shoot: document.getElementById('shootBtn')
    };

    // X·ª≠ l√Ω s·ª± ki·ªán n√∫t nh·∫•n
    function setupControlButtons() {
      // N√∫t di chuy·ªÉn
      controlButtons.up.addEventListener('mousedown', () => keys['ArrowUp'] = true);
      controlButtons.up.addEventListener('mouseup', () => keys['ArrowUp'] = false);
      controlButtons.up.addEventListener('mouseleave', () => keys['ArrowUp'] = false);
      
      controlButtons.left.addEventListener('mousedown', () => keys['ArrowLeft'] = true);
      controlButtons.left.addEventListener('mouseup', () => keys['ArrowLeft'] = false);
      controlButtons.left.addEventListener('mouseleave', () => keys['ArrowLeft'] = false);
      
      controlButtons.right.addEventListener('mousedown', () => keys['ArrowRight'] = true);
      controlButtons.right.addEventListener('mouseup', () => keys['ArrowRight'] = false);
      controlButtons.right.addEventListener('mouseleave', () => keys['ArrowRight'] = false);
      
      controlButtons.down.addEventListener('mousedown', () => keys['ArrowDown'] = true);
      controlButtons.down.addEventListener('mouseup', () => keys['ArrowDown'] = false);
      controlButtons.down.addEventListener('mouseleave', () => keys['ArrowDown'] = false);
      
      // N√∫t b·∫Øn
      controlButtons.shoot.addEventListener('mousedown', () => keys[' '] = true);
      controlButtons.shoot.addEventListener('mouseup', () => keys[' '] = false);
      controlButtons.shoot.addEventListener('mouseleave', () => keys[' '] = false);
      
      // H·ªó tr·ª£ touch cho mobile
      controlButtons.up.addEventListener('touchstart', (e) => { e.preventDefault(); keys['ArrowUp'] = true; });
      controlButtons.up.addEventListener('touchend', (e) => { e.preventDefault(); keys['ArrowUp'] = false; });
      
      controlButtons.left.addEventListener('touchstart', (e) => { e.preventDefault(); keys['ArrowLeft'] = true; });
      controlButtons.left.addEventListener('touchend', (e) => { e.preventDefault(); keys['ArrowLeft'] = false; });
      
      controlButtons.right.addEventListener('touchstart', (e) => { e.preventDefault(); keys['ArrowRight'] = true; });
      controlButtons.right.addEventListener('touchend', (e) => { e.preventDefault(); keys['ArrowRight'] = false; });
      
      controlButtons.down.addEventListener('touchstart', (e) => { e.preventDefault(); keys['ArrowDown'] = true; });
      controlButtons.down.addEventListener('touchend', (e) => { e.preventDefault(); keys['ArrowDown'] = false; });
      
      controlButtons.shoot.addEventListener('touchstart', (e) => { e.preventDefault(); keys[' '] = true; });
      controlButtons.shoot.addEventListener('touchend', (e) => { e.preventDefault(); keys[' '] = false; });
    }

    function gameLoop() {
      if (gameStarted) {
        update();
        requestAnimationFrame(gameLoop);
      }
    }

startBtn.addEventListener('click', function() {
      startBtn.style.display = 'none';
      canvas.style.display = 'block';
      movementControls.style.display = 'grid';
      shootControls.style.display = 'block';
      gameStarted = true;
      
      // ƒê·∫£m b·∫£o canvas fullscreen
      resizeCanvas();
      
      // Kh·ªüi t·∫°o h·ªá th·ªëng th·∫ø gi·ªõi
      initWorldSystem();
      
      // Thi·∫øt l·∫≠p ƒëi·ªÅu khi·ªÉn n√∫t
      setupControlButtons();
      
      bgm.currentTime = 0;
      // Try to play audio, fallback if blocked
      bgm.play().then(() => {
        // success
      }).catch(() => {
        // If failed, show a message and try again on next user gesture
        alert('Click anywhere to enable game music!');
        document.body.addEventListener('click', function tryPlay() {
          bgm.play();
          document.body.removeEventListener('click', tryPlay);
        });
      });
      gameLoop();
    });
  </script>
</body>
</html>
